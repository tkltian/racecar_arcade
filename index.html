<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rapid Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            touch-action: none;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: none;
        }

        /* Home Page Styles */
        #home-page {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
            padding: 20px;
        }
        #home-page h1 {
            font-size: clamp(36px, 10vw, 72px);
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5), 0 0 40px rgba(255,200,0,0.3);
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }
        #home-page .subtitle {
            font-size: clamp(14px, 4vw, 24px);
            color: #aaa;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }
        .menu-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .menu-btn {
            padding: 15px 40px;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: bold;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .play-btn {
            background: linear-gradient(45deg, #00b894, #00cec9);
            color: white;
            box-shadow: 0 8px 20px rgba(0,184,148,0.4);
        }
        .play-btn:hover, .play-btn:active {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(0,184,148,0.6);
        }
        .settings-btn {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            color: white;
            box-shadow: 0 8px 20px rgba(108,92,231,0.4);
        }
        .settings-btn:hover, .settings-btn:active {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(108,92,231,0.6);
        }

        /* Settings Panel */
        #settings-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 50, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            z-index: 200;
            width: 90%;
            max-width: 450px;
            max-height: 80vh;
            overflow-y: auto;
            color: white;
        }
        #settings-panel h2 {
            text-align: center;
            margin-bottom: 25px;
            font-size: clamp(24px, 5vw, 32px);
            color: #feca57;
        }
        .setting-group {
            margin-bottom: 20px;
        }
        .setting-group label {
            display: block;
            font-size: 16px;
            margin-bottom: 10px;
            color: #ddd;
        }
        .setting-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .setting-option {
            padding: 10px 15px;
            background: #2d2d44;
            border: 2px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            font-size: 13px;
            flex: 1;
            min-width: 80px;
            text-align: center;
        }
        .setting-option:hover, .setting-option:active {
            border-color: #6c5ce7;
        }
        .setting-option.selected {
            background: #6c5ce7;
            border-color: #a29bfe;
        }
        .obstacle-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .obstacle-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        .close-settings {
            margin-top: 25px;
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .close-settings:hover, .close-settings:active {
            transform: scale(1.02);
        }
        #settings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 199;
        }

        /* Game UI */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: clamp(16px, 4vw, 24px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            display: none;
        }
        #speedometer {
            font-size: clamp(24px, 6vw, 36px);
            font-weight: bold;
        }
        #timer {
            margin-top: 5px;
        }

        /* Health Bar */
        #health-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            max-width: 40vw;
            z-index: 100;
            display: none;
        }
        #health-label {
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 5px;
            text-align: center;
        }
        #health-bar-bg {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            border: 2px solid white;
            overflow: hidden;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00b894, #55efc4);
            transition: width 0.3s, background 0.3s;
            border-radius: 8px;
        }
        #health-bar.medium {
            background: linear-gradient(90deg, #fdcb6e, #ffeaa7);
        }
        #health-bar.low {
            background: linear-gradient(90deg, #d63031, #ff7675);
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(32px, 8vw, 48px);
            font-weight: bold;
            color: #ffff00;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9);
            z-index: 100;
            display: none;
            text-align: center;
            padding: 20px;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: clamp(10px, 2.5vw, 16px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            display: none;
        }
        #collision-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #back-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
            display: none;
            transition: all 0.3s;
        }
        #back-btn:hover, #back-btn:active {
            background: rgba(255,255,255,0.3);
        }

        /* Mobile Touch Controls */
        #touch-controls {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            z-index: 100;
            pointer-events: none;
        }
        .touch-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            border: 3px solid rgba(255,255,255,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            transition: background 0.1s;
        }
        .touch-btn:active, .touch-btn.active {
            background: rgba(255,255,255,0.6);
        }
        #touch-left {
            left: 20px;
            bottom: 60px;
        }
        #touch-right {
            left: 110px;
            bottom: 60px;
        }
        #touch-accel {
            right: 20px;
            bottom: 100px;
            background: rgba(0,255,0,0.3);
            border-color: rgba(0,255,0,0.6);
        }
        #touch-accel:active, #touch-accel.active {
            background: rgba(0,255,0,0.6);
        }
        #touch-brake {
            right: 20px;
            bottom: 20px;
            background: rgba(255,0,0,0.3);
            border-color: rgba(255,0,0,0.6);
        }
        #touch-brake:active, #touch-brake.active {
            background: rgba(255,0,0,0.6);
        }
        #touch-restart {
            right: 110px;
            bottom: 60px;
            width: 60px;
            height: 60px;
            font-size: 24px;
            background: rgba(255,255,0,0.3);
            border-color: rgba(255,255,0,0.6);
        }

        @media (max-width: 768px) {
            #touch-controls {
                display: block;
            }
            #instructions {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- Home Page -->
    <div id="home-page">
        <h1>Rapid Racing</h1>
        <p class="subtitle">
            Race through an exciting 3D track from the driver's seat!<br>
            Dodge obstacles, hit ramps to jump, and reach the finish line!
        </p>
        <div class="menu-buttons">
            <button class="menu-btn play-btn" onclick="startGame()">Play</button>
            <button class="menu-btn settings-btn" onclick="openSettings()">Settings</button>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-overlay" onclick="closeSettings()"></div>
    <div id="settings-panel">
        <h2>Game Settings</h2>

        <div class="setting-group">
            <label>Track Length</label>
            <div class="setting-options">
                <div class="setting-option" data-setting="trackLength" data-value="short">Short</div>
                <div class="setting-option selected" data-setting="trackLength" data-value="medium">Medium</div>
                <div class="setting-option" data-setting="trackLength" data-value="long">Long</div>
            </div>
        </div>

        <div class="setting-group">
            <label>Difficulty</label>
            <div class="setting-options">
                <div class="setting-option" data-setting="difficulty" data-value="easy">Easy</div>
                <div class="setting-option selected" data-setting="difficulty" data-value="medium">Medium</div>
                <div class="setting-option" data-setting="difficulty" data-value="hard">Hard</div>
            </div>
        </div>

        <div class="setting-group">
            <label>Obstacle Type</label>
            <div class="setting-options">
                <div class="setting-option" data-setting="obstacleType" data-value="cones">
                    <div class="obstacle-preview">
                        <div class="obstacle-icon" style="background: linear-gradient(#ff6600, #ffff00);"></div>
                        Cones
                    </div>
                </div>
                <div class="setting-option" data-setting="obstacleType" data-value="crates">
                    <div class="obstacle-preview">
                        <div class="obstacle-icon" style="background: #8B4513; border-radius: 3px;"></div>
                        Crates
                    </div>
                </div>
                <div class="setting-option selected" data-setting="obstacleType" data-value="labubu">
                    <div class="obstacle-preview">
                        <div class="obstacle-icon" style="background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);"></div>
                        Labubu
                    </div>
                </div>
            </div>
        </div>

        <button class="close-settings" onclick="closeSettings()">Save & Close</button>
    </div>

    <!-- Game Container -->
    <div id="game-container"></div>
    <div id="ui">
        <div id="speedometer">0 MPH</div>
        <div id="timer">Time: 0.00s</div>
        <div id="lap">Progress: 0%</div>
    </div>
    <div id="health-container">
        <div id="health-label">HEALTH</div>
        <div id="health-bar-bg">
            <div id="health-bar"></div>
        </div>
    </div>
    <div id="message"></div>
    <div id="instructions">
        Arrow Keys: UP = Accelerate | DOWN = Brake | LEFT/RIGHT = Steer<br>
        Press SPACE to restart | ESC for menu
    </div>
    <button id="back-btn" onclick="goToMenu()">Menu</button>
    <div id="collision-flash"></div>

    <!-- Mobile Touch Controls -->
    <div id="touch-controls">
        <div class="touch-btn" id="touch-left">◀</div>
        <div class="touch-btn" id="touch-right">▶</div>
        <div class="touch-btn" id="touch-accel">▲</div>
        <div class="touch-btn" id="touch-brake">▼</div>
        <div class="touch-btn" id="touch-restart">↻</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Settings
        let gameSettings = {
            trackLength: 'medium',
            difficulty: 'medium',
            obstacleType: 'labubu'
        };

        const TRACK_LENGTHS = {
            short: 800,
            medium: 1600,
            long: 2400
        };

        // Labubu colors based on Pop Mart "Big Into Energy" series
        // Secret (black) is rare: 1/36 probability
        // Other colors: 35/36 divided by 6 each
        const LABUBU_COLORS = [
            { name: 'Love', color: 0xff6b6b, gradient: 0xff8e8e, ringColor: 0xff6b6b },
            { name: 'Happiness', color: 0xffa502, gradient: 0xffc048, ringColor: 0xffa502 },
            { name: 'Loyalty', color: 0xfd79a8, gradient: 0xfdcb6e, ringColor: 0xfd79a8 },
            { name: 'Serenity', color: 0x00b894, gradient: 0x55efc4, ringColor: 0x00b894 },
            { name: 'Hope', color: 0x0984e3, gradient: 0x74b9ff, ringColor: 0x0984e3 },
            { name: 'Luck', color: 0x6c5ce7, gradient: 0xa29bfe, ringColor: 0x6c5ce7 }
        ];
        // Secret black Labubu - rare limited edition!
        const LABUBU_SECRET = { name: 'Secret', color: 0x1a1a1a, gradient: 0x444444, ringColor: 0xffd700 };

        function getRandomLabubuColor() {
            const roll = Math.random() * 36;
            if (roll < 1) {
                // 1/36 chance for Secret black Labubu
                return LABUBU_SECRET;
            } else {
                // 35/36 chance divided among 6 colors
                const colorIndex = Math.floor(Math.random() * 6);
                return LABUBU_COLORS[colorIndex];
            }
        }

        // Game constants
        const TRACK_WIDTH = 30;
        let TRACK_LENGTH = 800;
        const WALL_HEIGHT = 5;
        const CAR_MAX_SPEED = 2;
        const CAR_ACCELERATION = 0.02;
        const CAR_BRAKE_FORCE = 0.04;
        const CAR_FRICTION = 0.005;
        const CAR_TURN_SPEED = 0.03;
        const COLLISION_SLOWDOWN = 0.3;
        const MAX_HEALTH = 100;
        const COLLISION_DAMAGE = 15;
        const GRAVITY = 0.008;
        const JUMP_VELOCITY = 0.65;  // Big bounces! (doubled + 30% more)

        // Game state
        let scene, camera, renderer;
        let car = {
            speed: 0,
            position: null,
            rotation: 0,
            mesh: null,
            velocityY: 0,
            isJumping: false,
            onRamp: false,
            wasColliding: false  // Track if we were already colliding (for one-time damage)
        };
        let keys = {};
        let touchKeys = {};
        let obstacles = [];
        let ramps = [];
        let walls = [];
        let gameTime = 0;
        let gameStarted = false;
        let gameFinished = false;
        let gameOver = false;
        let lastCollisionTime = 0;
        let gameInitialized = false;
        let animationId = null;
        let health = MAX_HEALTH;

        // Detect mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

        // Settings UI handlers
        document.querySelectorAll('.setting-option').forEach(option => {
            option.addEventListener('click', () => {
                const setting = option.dataset.setting;
                const value = option.dataset.value;
                document.querySelectorAll(`[data-setting="${setting}"]`).forEach(opt => {
                    opt.classList.remove('selected');
                });
                option.classList.add('selected');
                gameSettings[setting] = value;
            });
        });

        // Touch controls setup
        function setupTouchControls() {
            const touchButtons = {
                'touch-left': 'ArrowLeft',
                'touch-right': 'ArrowRight',
                'touch-accel': 'ArrowUp',
                'touch-brake': 'ArrowDown'
            };

            Object.entries(touchButtons).forEach(([id, key]) => {
                const btn = document.getElementById(id);

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchKeys[key] = true;
                    btn.classList.add('active');
                    if (!gameStarted && !gameOver) {
                        gameStarted = true;
                        document.getElementById('message').style.display = 'none';
                    }
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touchKeys[key] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('touchcancel', (e) => {
                    touchKeys[key] = false;
                    btn.classList.remove('active');
                });
            });

            // Restart button
            document.getElementById('touch-restart').addEventListener('touchstart', (e) => {
                e.preventDefault();
                restartGame();
            });
        }

        function openSettings() {
            document.getElementById('settings-panel').style.display = 'block';
            document.getElementById('settings-overlay').style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settings-panel').style.display = 'none';
            document.getElementById('settings-overlay').style.display = 'none';
        }

        function startGame() {
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('health-container').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('back-btn').style.display = 'block';
            if (isMobile) {
                document.getElementById('touch-controls').style.display = 'block';
            }

            TRACK_LENGTH = TRACK_LENGTHS[gameSettings.trackLength];

            if (gameInitialized) {
                cleanupGame();
            }
            init();
        }

        function goToMenu() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('health-container').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('back-btn').style.display = 'none';
            document.getElementById('message').style.display = 'none';
            document.getElementById('touch-controls').style.display = 'none';
            document.getElementById('home-page').style.display = 'flex';
        }

        function cleanupGame() {
            const container = document.getElementById('game-container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            obstacles = [];
            ramps = [];
            walls = [];
            if (scene) {
                scene.traverse((object) => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(m => m.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            if (renderer) {
                renderer.dispose();
            }
        }

        function init() {
            gameInitialized = true;
            health = MAX_HEALTH;
            updateHealthBar();

            car.position = new THREE.Vector3(0, 1, 0);
            car.rotation = 0;
            car.speed = 0;
            car.velocityY = 0;
            car.isJumping = false;
            car.onRamp = false;
            car.wasColliding = false;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            createTrack();
            createCar();
            createRamps();
            createObstacles();
            createFinishLine();
            createScenery();

            // Set initial camera position behind the car
            const cameraOffset = new THREE.Vector3(0, 1.5, 0.5);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
            camera.position.copy(car.position).add(cameraOffset);
            camera.rotation.y = car.rotation;

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', onWindowResize);
            setupTouchControls();

            const message = document.getElementById('message');
            message.innerHTML = isMobile ? 'READY!<br>Touch controls to Start' : 'READY!<br>Press Arrow Keys to Start';
            message.style.display = 'block';
            message.style.color = '#ffff00';

            gameTime = 0;
            gameStarted = false;
            gameFinished = false;
            gameOver = false;

            lastTime = 0;
            animate(0);
        }

        function handleKeyDown(e) {
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Escape'].includes(e.code)) {
                e.preventDefault();
            }
            keys[e.code] = true;
            if (e.code === 'Escape') {
                goToMenu();
                return;
            }
            if (e.code === 'Space') {
                restartGame();
            }
            if (!gameStarted && !gameOver && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                gameStarted = true;
                document.getElementById('message').style.display = 'none';
            }
        }

        function handleKeyUp(e) {
            keys[e.code] = false;
        }

        function isKeyPressed(key) {
            return keys[key] || touchKeys[key];
        }

        // Track waypoints for curved path
        let trackWaypoints = [];

        function generateTrackWaypoints() {
            trackWaypoints = [];
            const segmentLength = 50;
            const numSegments = Math.ceil(TRACK_LENGTH / segmentLength);
            let x = 0, z = 0, angle = 0;

            for (let i = 0; i <= numSegments; i++) {
                trackWaypoints.push({ x, z, angle });

                // Add curves at certain points
                const progress = i / numSegments;
                if (progress > 0.1 && progress < 0.2) {
                    angle += 0.08; // Gentle right curve
                } else if (progress > 0.25 && progress < 0.35) {
                    angle -= 0.12; // Left curve
                } else if (progress > 0.45 && progress < 0.55) {
                    angle += 0.15; // Sharp right curve
                } else if (progress > 0.6 && progress < 0.7) {
                    angle -= 0.1; // Left curve
                } else if (progress > 0.8 && progress < 0.9) {
                    angle += 0.08; // Gentle right curve
                }

                // Move forward in current direction
                x += Math.sin(angle) * segmentLength;
                z -= Math.cos(angle) * segmentLength;
            }

            return trackWaypoints;
        }

        function getTrackPositionAt(distance) {
            const segmentLength = 50;
            const segmentIndex = Math.floor(distance / segmentLength);
            const segmentProgress = (distance % segmentLength) / segmentLength;

            if (segmentIndex >= trackWaypoints.length - 1) {
                return trackWaypoints[trackWaypoints.length - 1];
            }
            if (segmentIndex < 0) {
                return trackWaypoints[0];
            }

            const wp1 = trackWaypoints[segmentIndex];
            const wp2 = trackWaypoints[segmentIndex + 1];

            return {
                x: wp1.x + (wp2.x - wp1.x) * segmentProgress,
                z: wp1.z + (wp2.z - wp1.z) * segmentProgress,
                angle: wp1.angle + (wp2.angle - wp1.angle) * segmentProgress
            };
        }

        function createTrack() {
            generateTrackWaypoints();

            const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // Create track segments following the waypoints
            for (let i = 0; i < trackWaypoints.length - 1; i++) {
                const wp1 = trackWaypoints[i];
                const wp2 = trackWaypoints[i + 1];

                const dx = wp2.x - wp1.x;
                const dz = wp2.z - wp1.z;
                const segmentLength = Math.sqrt(dx * dx + dz * dz);
                const segmentAngle = Math.atan2(dx, -dz);

                // Track segment
                const segmentGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, segmentLength + 1);
                const segment = new THREE.Mesh(segmentGeometry, trackMaterial);
                segment.rotation.x = -Math.PI / 2;
                segment.rotation.z = -segmentAngle;
                segment.position.set(
                    (wp1.x + wp2.x) / 2,
                    0,
                    (wp1.z + wp2.z) / 2
                );
                segment.receiveShadow = true;
                scene.add(segment);

                // Center line dashes
                const numDashes = Math.floor(segmentLength / 20);
                for (let d = 0; d < numDashes; d++) {
                    const dashProgress = d / numDashes;
                    const dashX = wp1.x + dx * dashProgress;
                    const dashZ = wp1.z + dz * dashProgress;

                    const dashGeometry = new THREE.PlaneGeometry(0.3, 8);
                    const dash = new THREE.Mesh(dashGeometry, lineMaterial);
                    dash.rotation.x = -Math.PI / 2;
                    dash.rotation.z = -segmentAngle;
                    dash.position.set(dashX, 0.01, dashZ);
                    scene.add(dash);
                }

                // Side lines
                const perpX = Math.cos(segmentAngle);
                const perpZ = Math.sin(segmentAngle);

                // Left and right edge lines
                const lineGeometry = new THREE.PlaneGeometry(0.5, segmentLength + 1);

                const leftLine = new THREE.Mesh(lineGeometry, lineMaterial);
                leftLine.rotation.x = -Math.PI / 2;
                leftLine.rotation.z = -segmentAngle;
                leftLine.position.set(
                    (wp1.x + wp2.x) / 2 - perpX * (TRACK_WIDTH / 2 - 1),
                    0.01,
                    (wp1.z + wp2.z) / 2 - perpZ * (TRACK_WIDTH / 2 - 1)
                );
                scene.add(leftLine);

                const rightLine = new THREE.Mesh(lineGeometry, lineMaterial);
                rightLine.rotation.x = -Math.PI / 2;
                rightLine.rotation.z = -segmentAngle;
                rightLine.position.set(
                    (wp1.x + wp2.x) / 2 + perpX * (TRACK_WIDTH / 2 - 1),
                    0.01,
                    (wp1.z + wp2.z) / 2 + perpZ * (TRACK_WIDTH / 2 - 1)
                );
                scene.add(rightLine);

                // Store wall segments for collision detection (no visual mesh needed)
                walls.push({
                    x1: wp1.x - perpX * (TRACK_WIDTH / 2),
                    z1: wp1.z - perpZ * (TRACK_WIDTH / 2),
                    x2: wp2.x - perpX * (TRACK_WIDTH / 2),
                    z2: wp2.z - perpZ * (TRACK_WIDTH / 2),
                    type: 'left'
                });
                walls.push({
                    x1: wp1.x + perpX * (TRACK_WIDTH / 2),
                    z1: wp1.z + perpZ * (TRACK_WIDTH / 2),
                    x2: wp2.x + perpX * (TRACK_WIDTH / 2),
                    z2: wp2.z + perpZ * (TRACK_WIDTH / 2),
                    type: 'right'
                });
            }

            // Large grass area
            const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const grassGeometry = new THREE.PlaneGeometry(500, 500);
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.set(0, -0.1, -TRACK_LENGTH / 2);
            scene.add(grass);

            // More grass tiles to cover the curved track area
            for (let gx = -2; gx <= 2; gx++) {
                for (let gz = -4; gz <= 1; gz++) {
                    const grassTile = new THREE.Mesh(grassGeometry, grassMaterial);
                    grassTile.rotation.x = -Math.PI / 2;
                    grassTile.position.set(gx * 400, -0.15, gz * 400);
                    scene.add(grassTile);
                }
            }
        }

        function createCar() {
            const carGeometry = new THREE.BoxGeometry(3, 1.5, 5);
            const carMaterial = new THREE.MeshStandardMaterial({ color: 0x0066ff, transparent: true, opacity: 0 });
            car.mesh = new THREE.Mesh(carGeometry, carMaterial);
            car.mesh.position.copy(car.position);
            scene.add(car.mesh);

            // Simple hood visible from driver's view
            const hoodGeometry = new THREE.BoxGeometry(2.5, 0.3, 2.5);
            const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0x0066ff });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.set(0, -0.3, -2.2);
            car.mesh.add(hood);

            // Dashboard
            const dashboardGeometry = new THREE.BoxGeometry(2.5, 0.4, 0.8);
            const dashboardMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const dashboard = new THREE.Mesh(dashboardGeometry, dashboardMaterial);
            dashboard.position.set(0, -0.2, -0.8);
            car.mesh.add(dashboard);

            // Steering wheel
            const wheelGeometry = new THREE.TorusGeometry(0.25, 0.04, 8, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const steeringWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            steeringWheel.position.set(0, 0.1, -0.6);
            steeringWheel.rotation.x = Math.PI / 4;
            car.mesh.add(steeringWheel);
        }

        function createRamps() {
            // Create bounce pads at strategic positions along the curved track
            const rampCount = Math.floor(TRACK_LENGTH / 200);

            for (let i = 0; i < rampCount; i++) {
                // Position along the track (use waypoints)
                const trackProgress = (i + 1) / (rampCount + 1);
                const waypointIndex = Math.floor(trackProgress * (trackWaypoints.length - 1));
                const wp = trackWaypoints[waypointIndex];
                const nextWp = trackWaypoints[Math.min(waypointIndex + 1, trackWaypoints.length - 1)];
                const angle = Math.atan2(nextWp.x - wp.x, -(nextWp.z - wp.z));
                const perpX = Math.cos(angle);
                const perpZ = Math.sin(angle);

                // Random offset from center of track
                const lateralOffset = (Math.random() - 0.5) * (TRACK_WIDTH - 10);
                const padX = wp.x + perpX * lateralOffset;
                const padZ = wp.z + perpZ * lateralOffset;
                const padRadius = 3;

                const bouncePadGroup = new THREE.Group();

                // Base circle pad (transparent rainbow)
                const padGeometry = new THREE.CylinderGeometry(padRadius, padRadius, 0.3, 32);
                const padMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4
                });
                const pad = new THREE.Mesh(padGeometry, padMaterial);
                pad.position.y = 0.15;
                bouncePadGroup.add(pad);

                // Rainbow ring around the pad
                const ringGeometry = new THREE.TorusGeometry(padRadius, 0.2, 8, 32);
                const rainbowColors = [0xff0000, 0xff7700, 0xffff00, 0x00ff00, 0x0077ff, 0x8800ff];
                rainbowColors.forEach((color, idx) => {
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.6
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = 0.1 + idx * 0.15;
                    ring.scale.set(1 - idx * 0.1, 1 - idx * 0.1, 1);
                    bouncePadGroup.add(ring);
                });

                // Create 3D upward arrow
                const arrowGroup = new THREE.Group();

                // Arrow shaft
                const shaftGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                const shaftMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.7
                });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.position.y = 1.5;
                arrowGroup.add(shaft);

                // Arrow head (cone)
                const headGeometry = new THREE.ConeGeometry(0.8, 1.5, 8);
                const headMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.2;
                arrowGroup.add(head);

                // Add multiple smaller arrows around it for effect
                for (let a = 0; a < 3; a++) {
                    const smallArrow = new THREE.Group();
                    const smallShaft = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.15, 1, 6),
                        new THREE.MeshBasicMaterial({
                            color: rainbowColors[a * 2],
                            transparent: true,
                            opacity: 0.5
                        })
                    );
                    smallShaft.position.y = 1;
                    smallArrow.add(smallShaft);

                    const smallHead = new THREE.Mesh(
                        new THREE.ConeGeometry(0.4, 0.8, 6),
                        new THREE.MeshBasicMaterial({
                            color: rainbowColors[a * 2 + 1],
                            transparent: true,
                            opacity: 0.5
                        })
                    );
                    smallHead.position.y = 1.9;
                    smallArrow.add(smallHead);

                    const angle = (a / 3) * Math.PI * 2;
                    smallArrow.position.x = Math.cos(angle) * 1.5;
                    smallArrow.position.z = Math.sin(angle) * 1.5;
                    arrowGroup.add(smallArrow);
                }

                bouncePadGroup.add(arrowGroup);
                bouncePadGroup.position.set(padX, 0, padZ);
                bouncePadGroup.userData.arrowGroup = arrowGroup;
                scene.add(bouncePadGroup);

                ramps.push({
                    x: padX,
                    z: padZ,
                    radius: padRadius,
                    mesh: bouncePadGroup
                });
            }
        }

        function createObstacles() {
            const obstacleCount = Math.floor(TRACK_LENGTH / 50);
            const obstaclePositions = [];

            // Place obstacles along the curved track
            for (let i = 0; i < obstacleCount; i++) {
                const trackProgress = (i + 0.5) / obstacleCount;
                const waypointIndex = Math.floor(trackProgress * (trackWaypoints.length - 2)) + 1;
                const wp = trackWaypoints[waypointIndex];
                const nextWp = trackWaypoints[Math.min(waypointIndex + 1, trackWaypoints.length - 1)];
                const trackAngle = Math.atan2(nextWp.x - wp.x, -(nextWp.z - wp.z));
                const perpX = Math.cos(trackAngle);
                const perpZ = Math.sin(trackAngle);

                // Random offset from center of track
                const lateralOffset = (Math.random() - 0.5) * (TRACK_WIDTH - 6);
                obstaclePositions.push({
                    x: wp.x + perpX * lateralOffset,
                    z: wp.z + perpZ * lateralOffset
                });
            }

            const difficultyMultiplier = { easy: 0.6, medium: 1, hard: 1.5 };
            const actualCount = Math.floor(obstaclePositions.length * difficultyMultiplier[gameSettings.difficulty]);

            obstaclePositions.slice(0, actualCount).forEach((pos, index) => {
                // Check if position is on a bounce pad
                let onPad = false;
                for (const pad of ramps) {
                    const dx = pos.x - pad.x;
                    const dz = pos.z - pad.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    if (distance < pad.radius + 4) {
                        onPad = true;
                        break;
                    }
                }
                if (onPad) return;

                let obstacleMesh;
                let radius;

                if (gameSettings.obstacleType === 'cones') {
                    obstacleMesh = createCone(index);
                    radius = 2;
                } else if (gameSettings.obstacleType === 'crates') {
                    obstacleMesh = createCrate();
                    radius = 2.5;
                } else if (gameSettings.obstacleType === 'labubu') {
                    obstacleMesh = createLabubu(index);
                    radius = 2.5;
                }

                obstacleMesh.position.set(pos.x, obstacleMesh.userData.yOffset || 1.5, pos.z);
                obstacleMesh.castShadow = true;
                scene.add(obstacleMesh);

                const isMoving = gameSettings.difficulty === 'hard' && Math.random() > 0.5;

                obstacles.push({
                    mesh: obstacleMesh,
                    radius: radius,
                    isMoving: isMoving,
                    moveSpeed: 0.02 + Math.random() * 0.03,
                    moveDirection: Math.random() > 0.5 ? 1 : -1,
                    originalX: pos.x,
                    moveRange: 5 + Math.random() * 5
                });
            });
        }

        function createCone(index) {
            const colors = [0xff6600, 0xffff00, 0x00ff00, 0xff00ff];
            const coneGeometry = new THREE.CylinderGeometry(0.5, 1.5, 3, 8);
            const coneMaterial = new THREE.MeshStandardMaterial({ color: colors[index % colors.length] });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.userData.yOffset = 1.5;
            return cone;
        }

        function createCrate() {
            const crateGeometry = new THREE.BoxGeometry(3, 3, 3);
            const crateMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const crate = new THREE.Mesh(crateGeometry, crateMaterial);
            crate.userData.yOffset = 1.5;
            return crate;
        }

        function createLabubu(index) {
            const labubuGroup = new THREE.Group();
            // Use probability-based color selection (1/36 for Secret black, 35/36 divided by 6 for others)
            const labubuColor = getRandomLabubuColor();

            // Fuzzy/plush material for body
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: labubuColor.color,
                roughness: 1.0,
                metalness: 0
            });

            // Rounder, chubbier body (plush toy shape)
            const bodyGeometry = new THREE.SphereGeometry(1.8, 32, 32);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.set(1, 1.1, 0.9);
            body.position.y = 0;
            labubuGroup.add(body);

            // Larger, rounder head
            const headGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 2.2;
            head.scale.set(1.1, 1, 1);
            labubuGroup.add(head);

            // Two-toned pointy elf ears (signature Labubu feature)
            // Outer ear (main color)
            const outerEarGeometry = new THREE.ConeGeometry(0.5, 1.8, 8);
            const leftOuterEar = new THREE.Mesh(outerEarGeometry, bodyMaterial);
            leftOuterEar.position.set(-1.0, 3.5, 0);
            leftOuterEar.rotation.z = 0.4;
            labubuGroup.add(leftOuterEar);

            const rightOuterEar = new THREE.Mesh(outerEarGeometry, bodyMaterial);
            rightOuterEar.position.set(1.0, 3.5, 0);
            rightOuterEar.rotation.z = -0.4;
            labubuGroup.add(rightOuterEar);

            // Inner ear (gradient/lighter color)
            const innerEarGeometry = new THREE.ConeGeometry(0.3, 1.2, 8);
            const innerEarMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.9 });
            const leftInnerEar = new THREE.Mesh(innerEarGeometry, innerEarMaterial);
            leftInnerEar.position.set(-0.95, 3.4, 0.15);
            leftInnerEar.rotation.z = 0.4;
            labubuGroup.add(leftInnerEar);

            const rightInnerEar = new THREE.Mesh(innerEarGeometry, innerEarMaterial);
            rightInnerEar.position.set(0.95, 3.4, 0.15);
            rightInnerEar.rotation.z = -0.4;
            labubuGroup.add(rightInnerEar);

            // Large glittery eyes (wide, expressive)
            const eyeWhiteGeometry = new THREE.SphereGeometry(0.45, 16, 16);
            const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });

            const leftEyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
            leftEyeWhite.position.set(-0.5, 2.3, 1.2);
            leftEyeWhite.scale.set(1, 1.1, 0.5);
            labubuGroup.add(leftEyeWhite);

            const rightEyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
            rightEyeWhite.position.set(0.5, 2.3, 1.2);
            rightEyeWhite.scale.set(1, 1.1, 0.5);
            labubuGroup.add(rightEyeWhite);

            // Glitter/gradient iris (tonal gradient glitter eyes)
            const irisGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const irisMaterial = new THREE.MeshBasicMaterial({ color: labubuColor.gradient });
            const leftIris = new THREE.Mesh(irisGeometry, irisMaterial);
            leftIris.position.set(-0.5, 2.35, 1.35);
            leftIris.scale.set(1, 1, 0.3);
            labubuGroup.add(leftIris);

            const rightIris = new THREE.Mesh(irisGeometry, irisMaterial);
            rightIris.position.set(0.5, 2.35, 1.35);
            rightIris.scale.set(1, 1, 0.3);
            labubuGroup.add(rightIris);

            // Eye sparkles (multiple for glitter effect)
            const sparkleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const sparkleGeometry = new THREE.SphereGeometry(0.1, 8, 8);

            const leftSparkle1 = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
            leftSparkle1.position.set(-0.6, 2.5, 1.4);
            labubuGroup.add(leftSparkle1);
            const leftSparkle2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), sparkleMaterial);
            leftSparkle2.position.set(-0.4, 2.25, 1.4);
            labubuGroup.add(leftSparkle2);

            const rightSparkle1 = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
            rightSparkle1.position.set(0.4, 2.5, 1.4);
            labubuGroup.add(rightSparkle1);
            const rightSparkle2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), sparkleMaterial);
            rightSparkle2.position.set(0.6, 2.25, 1.4);
            labubuGroup.add(rightSparkle2);

            // Nose (matching color to toenails)
            const noseGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const noseMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.3 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 1.9, 1.45);
            nose.scale.set(1.2, 0.8, 0.8);
            labubuGroup.add(nose);

            // Wide mouth opening (mischievous grin)
            const mouthGeometry = new THREE.TorusGeometry(0.5, 0.12, 8, 16, Math.PI);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x1a0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.55, 1.25);
            mouth.rotation.x = Math.PI;
            mouth.rotation.z = Math.PI;
            labubuGroup.add(mouth);

            // Mouth interior
            const mouthInsideGeometry = new THREE.SphereGeometry(0.45, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const mouthInsideMaterial = new THREE.MeshBasicMaterial({ color: 0x330000, side: THREE.BackSide });
            const mouthInside = new THREE.Mesh(mouthInsideGeometry, mouthInsideMaterial);
            mouthInside.position.set(0, 1.55, 1.1);
            mouthInside.rotation.x = Math.PI / 2;
            labubuGroup.add(mouthInside);

            // 9 Sharp teeth (signature Labubu mischievous smile!)
            const toothMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const teethPositions = [
                { x: -0.36, size: 0.08 },
                { x: -0.27, size: 0.10 },
                { x: -0.16, size: 0.12 },
                { x: -0.06, size: 0.11 },
                { x: 0.04, size: 0.13 },  // Center tooth slightly bigger
                { x: 0.14, size: 0.11 },
                { x: 0.24, size: 0.12 },
                { x: 0.33, size: 0.10 },
                { x: 0.41, size: 0.08 }
            ];

            teethPositions.forEach((t, i) => {
                const toothGeometry = new THREE.ConeGeometry(t.size, 0.25, 6);
                const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                tooth.position.set(t.x, 1.35, 1.3);
                tooth.rotation.x = Math.PI;
                // One special colored tooth (signature feature)
                if (i === 4) {
                    tooth.material = new THREE.MeshBasicMaterial({ color: labubuColor.gradient });
                }
                labubuGroup.add(tooth);
            });

            // Chubby arms
            const armGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-1.8, 0.3, 0);
            leftArm.scale.set(0.8, 1.2, 0.8);
            labubuGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(1.8, 0.3, 0);
            rightArm.scale.set(0.8, 1.2, 0.8);
            labubuGroup.add(rightArm);

            // Cute stubby hands
            const handGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const leftHand = new THREE.Mesh(handGeometry, bodyMaterial);
            leftHand.position.set(-2.0, -0.2, 0.2);
            labubuGroup.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, bodyMaterial);
            rightHand.position.set(2.0, -0.2, 0.2);
            labubuGroup.add(rightHand);

            // Chubby feet with toenails
            const footGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const leftFoot = new THREE.Mesh(footGeometry, bodyMaterial);
            leftFoot.position.set(-0.8, -1.6, 0.4);
            leftFoot.scale.set(0.9, 0.5, 1.2);
            labubuGroup.add(leftFoot);

            const rightFoot = new THREE.Mesh(footGeometry, bodyMaterial);
            rightFoot.position.set(0.8, -1.6, 0.4);
            rightFoot.scale.set(0.9, 0.5, 1.2);
            labubuGroup.add(rightFoot);

            // Toenails (matching nose color)
            const toenailGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const toenailMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.3 });

            [-0.8, 0.8].forEach(footX => {
                for (let i = 0; i < 3; i++) {
                    const toenail = new THREE.Mesh(toenailGeometry, toenailMaterial);
                    toenail.position.set(footX + (i - 1) * 0.2, -1.65, 0.95);
                    toenail.scale.set(0.8, 0.5, 1);
                    labubuGroup.add(toenail);
                }
            });

            // Small tail puff
            const tailGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
            tail.position.set(0, -0.3, -1.5);
            labubuGroup.add(tail);

            // Glowing boundary ring (semi-transparent barrel) to show collision area
            const boundaryRadius = 2.5;  // Match collision radius
            const boundaryHeight = 6;
            const boundaryGeometry = new THREE.CylinderGeometry(boundaryRadius, boundaryRadius, boundaryHeight, 32, 1, true);
            const boundaryMaterial = new THREE.MeshBasicMaterial({
                color: labubuColor.ringColor,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide
            });
            const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            boundary.position.y = boundaryHeight / 2 - 1.5;
            labubuGroup.add(boundary);

            // Add a glowing ring at the base for extra visibility
            const baseRingGeometry = new THREE.TorusGeometry(boundaryRadius, 0.15, 8, 32);
            const baseRingMaterial = new THREE.MeshBasicMaterial({
                color: labubuColor.ringColor,
                transparent: true,
                opacity: 0.6
            });
            const baseRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.y = -1.5;
            labubuGroup.add(baseRing);

            // Add a second ring at the top
            const topRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
            topRing.rotation.x = Math.PI / 2;
            topRing.position.y = boundaryHeight - 1.5;
            labubuGroup.add(topRing);

            // For Secret black Labubu, add extra golden sparkle effect
            if (labubuColor.name === 'Secret') {
                const sparkleRingGeometry = new THREE.TorusGeometry(boundaryRadius + 0.3, 0.1, 8, 32);
                const sparkleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.8
                });
                for (let i = 0; i < 3; i++) {
                    const sparkleRing = new THREE.Mesh(sparkleRingGeometry, sparkleMaterial);
                    sparkleRing.rotation.x = Math.PI / 2;
                    sparkleRing.position.y = -1 + i * 2;
                    labubuGroup.add(sparkleRing);
                }
            }

            labubuGroup.userData.yOffset = 3;
            labubuGroup.userData.isLabubu = true;
            labubuGroup.userData.colorName = labubuColor.name;
            labubuGroup.userData.boundaryMesh = boundary;

            return labubuGroup;
        }

        function createFinishLine() {
            // Get the last waypoint for finish line position
            const lastWp = trackWaypoints[trackWaypoints.length - 1];
            const prevWp = trackWaypoints[trackWaypoints.length - 2];
            const finishAngle = Math.atan2(lastWp.x - prevWp.x, -(lastWp.z - prevWp.z));

            const finishGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 5);
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const squareSize = 32;
            for (let x = 0; x < canvas.width; x += squareSize) {
                for (let y = 0; y < canvas.height; y += squareSize) {
                    ctx.fillStyle = ((x + y) / squareSize) % 2 === 0 ? 'white' : 'black';
                    ctx.fillRect(x, y, squareSize, squareSize);
                }
            }
            const finishTexture = new THREE.CanvasTexture(canvas);
            finishTexture.wrapS = THREE.RepeatWrapping;
            finishTexture.wrapT = THREE.RepeatWrapping;
            finishTexture.repeat.set(4, 1);
            const finishMaterial = new THREE.MeshBasicMaterial({ map: finishTexture });
            const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);
            finishLine.rotation.x = -Math.PI / 2;
            finishLine.rotation.z = -finishAngle;
            finishLine.position.set(lastWp.x, 0.02, lastWp.z);
            scene.add(finishLine);

            // Store finish line position for collision detection
            window.finishLinePos = { x: lastWp.x, z: lastWp.z };

            // Calculate perpendicular direction (across the track)
            const perpX = Math.cos(finishAngle);
            const perpZ = Math.sin(finishAngle);

            // Create banner with "FINISH" text
            const bannerCanvas = document.createElement('canvas');
            bannerCanvas.width = 512;
            bannerCanvas.height = 128;
            const bannerCtx = bannerCanvas.getContext('2d');

            // Checkered background
            const checkSize = 32;
            for (let bx = 0; bx < bannerCanvas.width; bx += checkSize) {
                for (let by = 0; by < bannerCanvas.height; by += checkSize) {
                    bannerCtx.fillStyle = ((bx + by) / checkSize) % 2 === 0 ? '#ffffff' : '#000000';
                    bannerCtx.fillRect(bx, by, checkSize, checkSize);
                }
            }

            // "FINISH" text
            bannerCtx.fillStyle = '#ff0000';
            bannerCtx.font = 'bold 80px Arial';
            bannerCtx.textAlign = 'center';
            bannerCtx.textBaseline = 'middle';
            bannerCtx.strokeStyle = '#ffffff';
            bannerCtx.lineWidth = 4;
            bannerCtx.strokeText('FINISH', bannerCanvas.width / 2, bannerCanvas.height / 2);
            bannerCtx.fillText('FINISH', bannerCanvas.width / 2, bannerCanvas.height / 2);

            // Calculate support post positions first
            const leftPostX = lastWp.x - perpX * (TRACK_WIDTH / 2 + 2);
            const leftPostZ = lastWp.z - perpZ * (TRACK_WIDTH / 2 + 2);
            const rightPostX = lastWp.x + perpX * (TRACK_WIDTH / 2 + 2);
            const rightPostZ = lastWp.z + perpZ * (TRACK_WIDTH / 2 + 2);

            // Create banner that spans between the posts
            const bannerTexture = new THREE.CanvasTexture(bannerCanvas);
            const bannerWidth = Math.sqrt(Math.pow(rightPostX - leftPostX, 2) + Math.pow(rightPostZ - leftPostZ, 2));
            const bannerGeometry = new THREE.PlaneGeometry(bannerWidth, 3);
            const bannerMaterial = new THREE.MeshBasicMaterial({ map: bannerTexture, side: THREE.DoubleSide });
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);

            // Position banner at center between posts, at height 8
            banner.position.set(
                (leftPostX + rightPostX) / 2,
                8,
                (leftPostZ + rightPostZ) / 2
            );

            // Calculate rotation to span between posts
            // PlaneGeometry width is along X axis, so we need rotation that aligns X with left-to-right direction
            const bannerAngle = Math.atan2(leftPostZ - rightPostZ, rightPostX - leftPostX);
            banner.rotation.y = bannerAngle;
            scene.add(banner);

            // Support posts on left and right sides of track
            const supportGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 8);
            const supportMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

            const leftSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            leftSupport.position.set(leftPostX, 5, leftPostZ);
            scene.add(leftSupport);

            const rightSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            rightSupport.position.set(rightPostX, 5, rightPostZ);
            scene.add(rightSupport);
        }

        function createScenery() {
            // Place trees along the curved track
            const treePositions = [];
            for (let i = 0; i < trackWaypoints.length; i += 2) {
                const wp = trackWaypoints[i];
                const nextWp = trackWaypoints[Math.min(i + 1, trackWaypoints.length - 1)];
                const angle = Math.atan2(nextWp.x - wp.x, -(nextWp.z - wp.z));
                const perpX = Math.cos(angle);
                const perpZ = Math.sin(angle);

                // Trees on both sides of track
                treePositions.push({
                    x: wp.x - perpX * (TRACK_WIDTH / 2 + 15 + Math.random() * 20),
                    z: wp.z - perpZ * (TRACK_WIDTH / 2 + 15 + Math.random() * 20)
                });
                treePositions.push({
                    x: wp.x + perpX * (TRACK_WIDTH / 2 + 15 + Math.random() * 20),
                    z: wp.z + perpZ * (TRACK_WIDTH / 2 + 15 + Math.random() * 20)
                });
            }

            treePositions.forEach(pos => {
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(pos.x + (Math.random() - 0.5) * 5, 2.5, pos.z + (Math.random() - 0.5) * 5);
                trunk.castShadow = true;
                scene.add(trunk);

                const foliageGeometry = new THREE.ConeGeometry(3, 6, 8);
                const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(trunk.position.x, 7, trunk.position.z);
                foliage.castShadow = true;
                scene.add(foliage);
            });

            const gridMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = 0; i < 3; i++) {
                const gridGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 0.5);
                const gridLine = new THREE.Mesh(gridGeometry, gridMaterial);
                gridLine.rotation.x = -Math.PI / 2;
                gridLine.position.set(0, 0.01, 5 - i * 3);
                scene.add(gridLine);
            }
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.isMoving) {
                    obstacle.mesh.position.x += obstacle.moveSpeed * obstacle.moveDirection;
                    if (Math.abs(obstacle.mesh.position.x - obstacle.originalX) > obstacle.moveRange) {
                        obstacle.moveDirection *= -1;
                    }
                    const maxX = TRACK_WIDTH / 2 - 3;
                    if (obstacle.mesh.position.x > maxX) {
                        obstacle.mesh.position.x = maxX;
                        obstacle.moveDirection = -1;
                    } else if (obstacle.mesh.position.x < -maxX) {
                        obstacle.mesh.position.x = -maxX;
                        obstacle.moveDirection = 1;
                    }
                    if (obstacle.mesh.userData && obstacle.mesh.userData.isLabubu) {
                        obstacle.mesh.rotation.y = obstacle.moveDirection > 0 ? Math.PI / 2 : -Math.PI / 2;
                    }
                }
            });
        }

        function updateBouncePads() {
            const time = Date.now() * 0.003;
            ramps.forEach((pad, index) => {
                if (pad.mesh && pad.mesh.userData.arrowGroup) {
                    const arrowGroup = pad.mesh.userData.arrowGroup;
                    // Bobbing animation
                    arrowGroup.position.y = Math.sin(time + index) * 0.3;
                    // Slow rotation
                    arrowGroup.rotation.y = time * 0.5;

                    // Pulse effect when recently bounced
                    if (pad.mesh.userData.bounceTime) {
                        const elapsed = Date.now() - pad.mesh.userData.bounceTime;
                        if (elapsed < 500) {
                            const scale = 1 + Math.sin(elapsed * 0.02) * 0.3;
                            arrowGroup.scale.set(scale, scale, scale);
                        } else {
                            arrowGroup.scale.set(1, 1, 1);
                            pad.mesh.userData.bounceTime = null;
                        }
                    }
                }
            });
        }

        function checkRamps() {
            // Don't trigger bounce if already jumping high
            if (car.isJumping && car.position.y > 2) {
                return;
            }

            for (const pad of ramps) {
                const dx = car.position.x - pad.x;
                const dz = car.position.z - pad.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                // Check if car is on the bounce pad
                if (distance < pad.radius && car.position.y < 2) {
                    // Launch the car upward! Height based on speed
                    const speedFactor = Math.max(0.3, car.speed / CAR_MAX_SPEED);
                    car.velocityY = JUMP_VELOCITY * 1.5 * speedFactor;
                    car.isJumping = true;
                    car.onRamp = true; // Mark as on pad to prevent collision damage

                    // Visual feedback - make arrows pulse (handled in animate)
                    if (pad.mesh && pad.mesh.userData.arrowGroup) {
                        pad.mesh.userData.bounceTime = Date.now();
                    }
                    break; // Only trigger one pad at a time
                }
            }

            // Reset onRamp if not on any pad
            let onAnyPad = false;
            for (const pad of ramps) {
                const dx = car.position.x - pad.x;
                const dz = car.position.z - pad.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < pad.radius) {
                    onAnyPad = true;
                    break;
                }
            }
            if (!onAnyPad && car.position.y <= 1.1) {
                car.onRamp = false;
            }
        }

        // Check if a position is on the track
        function isOnTrack(x, z) {
            // Find the closest point on the track centerline
            let minDist = Infinity;

            for (let i = 0; i < trackWaypoints.length - 1; i++) {
                const wp1 = trackWaypoints[i];
                const wp2 = trackWaypoints[i + 1];

                // Find closest point on this segment
                const closest = closestPointOnSegment(x, z, wp1.x, wp1.z, wp2.x, wp2.z);
                const dx = x - closest.x;
                const dz = z - closest.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < minDist) {
                    minDist = dist;
                }
            }

            // Check if within track width (with a small margin)
            return minDist < (TRACK_WIDTH / 2 + 2);
        }

        function updateCarPhysics() {
            // Apply gravity when jumping
            if (car.isJumping || car.position.y > 1.01) {
                const wasInAir = car.position.y > 1.1;
                car.velocityY -= GRAVITY;
                car.position.y += car.velocityY;

                if (car.position.y <= 1) {
                    car.position.y = 1;
                    car.velocityY = 0;
                    car.isJumping = false;

                    // Check if landed outside the track
                    if (wasInAir && !isOnTrack(car.position.x, car.position.z)) {
                        triggerOffTrackGameOver();
                    }
                }
            }
        }

        function triggerOffTrackGameOver() {
            gameOver = true;
            gameFinished = true;
            const message = document.getElementById('message');
            message.innerHTML = `WASTED!<br><span style="font-size: 24px; color: #ff6b6b;">Landed off the track!</span><br><span style="font-size: 20px;">Press SPACE to try again</span>`;
            message.style.display = 'block';
            message.style.color = '#ff0000';
        }

        function updateCar(delta) {
            if (!gameStarted || gameFinished || gameOver) return;

            const prevX = car.position.x;
            const prevZ = car.position.z;
            const isInAir = car.isJumping || car.position.y > 1.1;

            if (isInAir) {
                // In air: no acceleration allowed
                // Braking at half rate, can only slow down to 0 (no reverse)
                if (isKeyPressed('ArrowDown') && car.speed > 0) {
                    car.speed -= CAR_BRAKE_FORCE / 2;
                    if (car.speed < 0) car.speed = 0;
                }
            } else {
                // On ground: normal controls
                if (isKeyPressed('ArrowUp')) {
                    car.speed += CAR_ACCELERATION;
                }
                if (isKeyPressed('ArrowDown')) {
                    car.speed -= CAR_BRAKE_FORCE;
                }
            }

            car.speed *= (1 - CAR_FRICTION);

            // Speed limits: full reverse only on ground, no reverse in air
            if (isInAir) {
                car.speed = Math.max(0, Math.min(CAR_MAX_SPEED, car.speed));
            } else {
                car.speed = Math.max(-CAR_MAX_SPEED / 2, Math.min(CAR_MAX_SPEED, car.speed));
            }

            if (Math.abs(car.speed) > 0.01) {
                // Half turning capability when in air
                const turnSpeed = isInAir ? CAR_TURN_SPEED / 2 : CAR_TURN_SPEED;
                if (isKeyPressed('ArrowLeft')) {
                    car.rotation += turnSpeed * Math.sign(car.speed);
                }
                if (isKeyPressed('ArrowRight')) {
                    car.rotation -= turnSpeed * Math.sign(car.speed);
                }
            }

            const moveX = -Math.sin(car.rotation) * car.speed;
            const moveZ = -Math.cos(car.rotation) * car.speed;

            car.position.x += moveX;
            car.position.z += moveZ;

            checkRamps();
            updateCarPhysics();

            // Only check collisions if not high in the air
            if (car.position.y < 3) {
                checkCollisions(prevX, prevZ, moveX, moveZ);
            }

            car.mesh.position.copy(car.position);
            car.mesh.rotation.y = car.rotation;

            const cameraOffset = new THREE.Vector3(0, 1.5, 0.5);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
            camera.position.copy(car.position).add(cameraOffset);
            camera.rotation.y = car.rotation;

            // Check if reached finish line
            if (window.finishLinePos) {
                const distToFinish = Math.sqrt(
                    Math.pow(car.position.x - window.finishLinePos.x, 2) +
                    Math.pow(car.position.z - window.finishLinePos.z, 2)
                );
                if (distToFinish < 15) {
                    finishGame();
                }
            }
        }

        const CAR_HALF_WIDTH = 1.5;

        // Helper function to find closest point on a line segment
        function closestPointOnSegment(px, pz, x1, z1, x2, z2) {
            const dx = x2 - x1;
            const dz = z2 - z1;
            const len2 = dx * dx + dz * dz;
            if (len2 === 0) return { x: x1, z: z1 };

            let t = ((px - x1) * dx + (pz - z1) * dz) / len2;
            t = Math.max(0, Math.min(1, t));

            return {
                x: x1 + t * dx,
                z: z1 + t * dz
            };
        }

        function checkCollisions(prevX, prevZ, moveX, moveZ) {
            const currentTime = Date.now();
            const collisionCooldown = 300;
            let collided = false;

            const carRadius = CAR_HALF_WIDTH;

            // Check wall segment collisions
            for (const wall of walls) {
                if (!wall.x1) continue; // Skip old-style walls

                const closest = closestPointOnSegment(
                    car.position.x, car.position.z,
                    wall.x1, wall.z1, wall.x2, wall.z2
                );

                const dx = car.position.x - closest.x;
                const dz = car.position.z - closest.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < carRadius) {
                    // Push car away from wall
                    if (dist > 0.01) {
                        const nx = dx / dist;
                        const nz = dz / dist;
                        car.position.x = closest.x + nx * carRadius;
                        car.position.z = closest.z + nz * carRadius;
                    }
                    collided = true;
                }
            }

            // Check obstacle collisions
            obstacles.forEach(obstacle => {
                const dx = car.position.x - obstacle.mesh.position.x;
                const dz = car.position.z - obstacle.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDist = obstacle.radius + carRadius;

                if (distance < minDist) {
                    if (distance > 0.01) {
                        const nx = dx / distance;
                        const nz = dz / distance;
                        car.position.x = obstacle.mesh.position.x + nx * minDist;
                        car.position.z = obstacle.mesh.position.z + nz * minDist;
                        const dotProduct = (moveX * nx + moveZ * nz);
                        if (dotProduct < 0) {
                            collided = true;
                        }
                    } else {
                        car.position.x = prevX;
                        car.position.z = prevZ;
                        collided = true;
                    }
                }
            });

            // Prevent going backwards past start
            if (car.position.z > 10) {
                car.position.z = 10;
                collided = true;
            }

            // Only apply collision damage once when ENTERING a collision
            // (not continuously while staying in collision)
            if (collided && !car.onRamp) {
                if (!car.wasColliding) {
                    // Just entered a collision - apply damage once
                    applyCollisionEffect();
                }
                car.wasColliding = true;
            } else {
                // No longer colliding - reset the flag
                car.wasColliding = false;
            }
        }

        function applyCollisionEffect() {
            car.speed *= COLLISION_SLOWDOWN;
            lastCollisionTime = Date.now();

            // Reduce health
            health -= COLLISION_DAMAGE;
            if (health < 0) health = 0;
            updateHealthBar();

            const flash = document.getElementById('collision-flash');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 100);

            // Check for game over
            if (health <= 0) {
                triggerGameOver();
            }
        }

        function updateHealthBar() {
            const healthBar = document.getElementById('health-bar');
            const percentage = (health / MAX_HEALTH) * 100;
            healthBar.style.width = percentage + '%';

            healthBar.classList.remove('medium', 'low');
            if (percentage <= 30) {
                healthBar.classList.add('low');
            } else if (percentage <= 60) {
                healthBar.classList.add('medium');
            }
        }

        function triggerGameOver() {
            gameOver = true;
            gameFinished = true;
            const message = document.getElementById('message');
            message.innerHTML = `WASTED!<br><span style="font-size: 24px; color: #ff6b6b;">Your car is destroyed!</span><br><span style="font-size: 20px;">Press SPACE to try again</span>`;
            message.style.display = 'block';
            message.style.color = '#ff0000';
        }

        function finishGame() {
            gameFinished = true;
            const message = document.getElementById('message');
            message.innerHTML = `FINISH!<br>Time: ${gameTime.toFixed(2)}s<br><span style="font-size: 24px">Press SPACE to restart</span>`;
            message.style.display = 'block';
            message.style.color = '#00ff00';
        }

        function restartGame() {
            car.position.set(0, 1, 0);
            car.rotation = 0;
            car.speed = 0;
            car.velocityY = 0;
            car.isJumping = false;
            car.onRamp = false;
            car.wasColliding = false;
            gameTime = 0;
            gameStarted = false;
            gameFinished = false;
            gameOver = false;
            health = MAX_HEALTH;
            updateHealthBar();

            car.mesh.position.copy(car.position);
            car.mesh.rotation.y = car.rotation;
            camera.position.set(0, 2.5, 0.5);
            camera.rotation.y = 0;

            obstacles.forEach(obstacle => {
                if (obstacle.isMoving) {
                    obstacle.mesh.position.x = obstacle.originalX;
                }
            });

            const message = document.getElementById('message');
            message.innerHTML = isMobile ? 'READY!<br>Touch controls to Start' : 'READY!<br>Press Arrow Keys to Start';
            message.style.display = 'block';
            message.style.color = '#ffff00';
        }

        function updateUI() {
            const mph = Math.abs(car.speed * 60).toFixed(0);
            document.getElementById('speedometer').textContent = `${mph} MPH`;
            document.getElementById('timer').textContent = `Time: ${gameTime.toFixed(2)}s`;

            // Calculate progress along curved track
            let closestDist = Infinity;
            let closestIndex = 0;
            for (let i = 0; i < trackWaypoints.length; i++) {
                const wp = trackWaypoints[i];
                const dist = Math.sqrt(
                    Math.pow(car.position.x - wp.x, 2) +
                    Math.pow(car.position.z - wp.z, 2)
                );
                if (dist < closestDist) {
                    closestDist = dist;
                    closestIndex = i;
                }
            }
            const progress = Math.max(0, Math.min(100, (closestIndex / (trackWaypoints.length - 1)) * 100));
            document.getElementById('lap').textContent = `Progress: ${progress.toFixed(0)}%`;
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        let lastTime = 0;
        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);
            const delta = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (gameStarted && !gameFinished) {
                gameTime += delta;
            }

            updateObstacles();
            updateBouncePads();
            updateCar(delta);
            updateUI();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
