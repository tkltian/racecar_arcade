<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rapid Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            touch-action: none;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: none;
        }

        /* Home Page Styles */
        #home-page {
            width: 100vw;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
            padding: 20px 20px 40px 20px;
        }
        body.menu-active {
            overflow-y: auto;
            touch-action: auto;
        }
        #home-page h1 {
            font-size: clamp(24px, 7vw, 42px);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 30px rgba(255,200,0,0.3);
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }
        #home-page .subtitle {
            font-size: clamp(11px, 3vw, 16px);
            color: #aaa;
            margin-bottom: 20px;
            text-align: center;
            max-width: 500px;
            line-height: 1.4;
        }
        .track-picker {
            margin-bottom: 15px;
        }
        .track-picker-label {
            font-size: clamp(14px, 3vw, 16px);
            color: #feca57;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .track-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .track-option {
            padding: 8px 10px;
            background: rgba(45, 45, 68, 0.8);
            border: 2px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 12px;
            min-width: 70px;
            text-align: center;
        }
        .track-option:hover {
            border-color: #6c5ce7;
            transform: translateY(-3px);
        }
        .track-option.selected {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            border-color: #a29bfe;
            box-shadow: 0 5px 20px rgba(108,92,231,0.5);
        }
        .track-option .track-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        .track-preview {
            width: 55px;
            height: 55px;
            background: rgba(20, 20, 35, 0.9);
            border-radius: 6px;
            margin-bottom: 5px;
        }
        .track-name {
            font-size: 10px;
            color: #ddd;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .track-option.selected .track-name {
            color: white;
            font-weight: bold;
        }
        .difficulty-picker {
            margin-bottom: 20px;
        }
        .difficulty-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .difficulty-option {
            padding: 8px 16px;
            background: rgba(45, 45, 68, 0.8);
            border: 2px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 14px;
        }
        .difficulty-option:hover {
            border-color: #6c5ce7;
        }
        .difficulty-option.selected {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            border-color: #a29bfe;
        }
        .menu-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .menu-btn {
            padding: 15px 40px;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: bold;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .play-btn {
            background: linear-gradient(45deg, #00b894, #00cec9);
            color: white;
            box-shadow: 0 8px 20px rgba(0,184,148,0.4);
        }
        .play-btn:hover, .play-btn:active {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(0,184,148,0.6);
        }
        .settings-btn {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
            color: white;
            box-shadow: 0 8px 20px rgba(108,92,231,0.4);
        }
        .settings-btn:hover, .settings-btn:active {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(108,92,231,0.6);
        }
        .multiplayer-btn {
            background: linear-gradient(45deg, #0984e3, #74b9ff);
            color: white;
            box-shadow: 0 8px 20px rgba(9,132,227,0.4);
        }
        .multiplayer-btn:hover, .multiplayer-btn:active {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(9,132,227,0.6);
        }
        .menu-footer {
            margin-top: 25px;
            text-align: center;
            color: #888;
            font-size: 12px;
            line-height: 1.6;
        }
        .menu-footer .dedication {
            color: #a29bfe;
            font-style: italic;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .menu-footer .copyright {
            color: #666;
            font-size: 12px;
        }

        /* Settings Panel */
        #settings-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 50, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            z-index: 200;
            width: 90%;
            max-width: 450px;
            max-height: 80vh;
            overflow-y: auto;
            color: white;
        }
        #settings-panel h2 {
            text-align: center;
            margin-bottom: 25px;
            font-size: clamp(24px, 5vw, 32px);
            color: #feca57;
        }
        .setting-group {
            margin-bottom: 20px;
        }
        .setting-group label {
            display: block;
            font-size: 16px;
            margin-bottom: 10px;
            color: #ddd;
        }
        .setting-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .setting-option {
            padding: 10px 15px;
            background: #2d2d44;
            border: 2px solid #444;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            font-size: 13px;
            flex: 1;
            min-width: 80px;
            text-align: center;
        }
        .setting-option:hover, .setting-option:active {
            border-color: #6c5ce7;
        }
        .setting-option.selected {
            background: #6c5ce7;
            border-color: #a29bfe;
        }
        .obstacle-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .obstacle-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        .close-settings {
            margin-top: 25px;
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .close-settings:hover, .close-settings:active {
            transform: scale(1.02);
        }
        #settings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 199;
        }

        /* Multiplayer Lobby */
        #multiplayer-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 199;
        }
        #multiplayer-lobby {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 50, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            z-index: 200;
            width: 90%;
            max-width: 400px;
            color: white;
            text-align: center;
        }
        #multiplayer-lobby h2 {
            margin-bottom: 20px;
            font-size: 28px;
            color: #feca57;
        }
        .mp-section p {
            margin: 10px 0;
            color: #ccc;
        }
        .mp-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        .mp-btn {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .mp-btn.host-btn {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
        }
        .mp-btn.join-btn {
            background: linear-gradient(135deg, #0984e3, #74b9ff);
            color: white;
        }
        .mp-btn.start-btn {
            background: linear-gradient(135deg, #fdcb6e, #f39c12);
            color: #333;
            font-weight: bold;
        }
        .mp-btn.cancel-btn {
            background: #555;
            color: white;
        }
        .mp-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        #room-code {
            font-size: 48px;
            font-weight: bold;
            letter-spacing: 10px;
            color: #feca57;
            margin: 20px 0;
            font-family: monospace;
        }
        #join-code-input {
            font-size: 32px;
            padding: 10px 20px;
            text-align: center;
            letter-spacing: 8px;
            width: 200px;
            border: 3px solid #feca57;
            border-radius: 10px;
            background: #2d2d44;
            color: white;
            text-transform: uppercase;
        }
        #join-code-input::placeholder {
            letter-spacing: 2px;
            font-size: 16px;
        }
        .mp-status {
            font-size: 14px;
            color: #aaa;
            margin-top: 15px;
        }
        .mp-connected-msg {
            font-size: 20px;
            color: #00b894 !important;
            font-weight: bold;
        }

        /* Game UI */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: clamp(16px, 4vw, 24px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            display: none;
        }
        #speedometer {
            font-size: clamp(24px, 6vw, 36px);
            font-weight: bold;
        }
        #timer {
            margin-top: 5px;
        }

        /* Health Bar */
        #health-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            max-width: 40vw;
            z-index: 100;
            display: none;
        }
        #health-label {
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 5px;
            text-align: center;
        }
        #health-bar-bg {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            border: 2px solid white;
            overflow: hidden;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00b894, #55efc4);
            transition: width 0.3s, background 0.3s;
            border-radius: 8px;
        }
        #health-bar.medium {
            background: linear-gradient(90deg, #fdcb6e, #ffeaa7);
        }
        #health-bar.low {
            background: linear-gradient(90deg, #d63031, #ff7675);
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(32px, 8vw, 48px);
            font-weight: bold;
            color: #ffff00;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9);
            z-index: 100;
            display: none;
            text-align: center;
            padding: 20px;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: clamp(10px, 2.5vw, 16px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            display: none;
        }
        #collision-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #back-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            z-index: 100;
            display: none;
            transition: all 0.3s;
        }
        #back-btn:hover, #back-btn:active {
            background: rgba(255,255,255,0.3);
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            z-index: 100;
            display: none;
            overflow: hidden;
        }
        #minimap-label {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            text-transform: uppercase;
        }
        #minimap {
            width: 100%;
            height: 100%;
        }

        /* Mobile Touch Controls */
        #touch-controls {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            z-index: 100;
            pointer-events: none;
        }
        .touch-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            border: 3px solid rgba(255,255,255,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            transition: background 0.1s;
        }
        .touch-btn:active, .touch-btn.active {
            background: rgba(255,255,255,0.6);
        }
        #touch-left {
            left: 20px;
            bottom: 60px;
        }
        #touch-right {
            left: 110px;
            bottom: 60px;
        }
        #touch-accel {
            right: 20px;
            bottom: 100px;
            background: rgba(0,255,0,0.3);
            border-color: rgba(0,255,0,0.6);
        }
        #touch-accel:active, #touch-accel.active {
            background: rgba(0,255,0,0.6);
        }
        #touch-brake {
            right: 20px;
            bottom: 20px;
            background: rgba(255,0,0,0.3);
            border-color: rgba(255,0,0,0.6);
        }
        #touch-brake:active, #touch-brake.active {
            background: rgba(255,0,0,0.6);
        }
        #touch-restart {
            right: 110px;
            bottom: 60px;
            width: 60px;
            height: 60px;
            font-size: 24px;
            background: rgba(255,255,0,0.3);
            border-color: rgba(255,255,0,0.6);
        }

        @media (max-width: 768px) {
            #instructions {
                display: none !important;
            }
        }
    </style>
</head>
<body class="menu-active">
    <!-- Home Page -->
    <div id="home-page">
        <h1>Rapid Racing</h1>
        <p class="subtitle">
            Race through an exciting 3D track from the driver's seat!<br>
            Dodge obstacles, hit ramps to jump, and reach the finish line!
        </p>
        <div class="track-picker">
            <div class="track-picker-label">Select Track</div>
            <div class="track-options">
                <div class="track-option" data-track="classic" onclick="selectTrack('classic')">
                    <canvas class="track-preview" id="preview-classic"></canvas>
                    <div class="track-name">Classic</div>
                </div>
                <div class="track-option selected" data-track="serpentine" onclick="selectTrack('serpentine')">
                    <canvas class="track-preview" id="preview-serpentine"></canvas>
                    <div class="track-name">Serpentine</div>
                </div>
                <div class="track-option" data-track="zigzag" onclick="selectTrack('zigzag')">
                    <canvas class="track-preview" id="preview-zigzag"></canvas>
                    <div class="track-name">Zig-Zag</div>
                </div>
                <div class="track-option" data-track="spiral" onclick="selectTrack('spiral')">
                    <canvas class="track-preview" id="preview-spiral"></canvas>
                    <div class="track-name">Spiral</div>
                </div>
                <div class="track-option" data-track="hairpin" onclick="selectTrack('hairpin')">
                    <canvas class="track-preview" id="preview-hairpin"></canvas>
                    <div class="track-name">Hairpin</div>
                </div>
                <div class="track-option" data-track="insane" onclick="selectTrack('insane')">
                    <canvas class="track-preview" id="preview-insane"></canvas>
                    <div class="track-name">Insane</div>
                </div>
                <div class="track-option" data-track="grandprix" onclick="selectTrack('grandprix')">
                    <canvas class="track-preview" id="preview-grandprix"></canvas>
                    <div class="track-name">Grand Prix</div>
                </div>
                <div class="track-option" data-track="mountain" onclick="selectTrack('mountain')">
                    <canvas class="track-preview" id="preview-mountain"></canvas>
                    <div class="track-name">Mountain</div>
                </div>
                <div class="track-option" data-track="coastal" onclick="selectTrack('coastal')">
                    <canvas class="track-preview" id="preview-coastal"></canvas>
                    <div class="track-name">Coastal</div>
                </div>
                <div class="track-option" data-track="championship" onclick="selectTrack('championship')">
                    <canvas class="track-preview" id="preview-championship"></canvas>
                    <div class="track-name">Championship</div>
                </div>
            </div>
        </div>
        <div class="difficulty-picker">
            <div class="track-picker-label">Difficulty</div>
            <div class="difficulty-options">
                <div class="difficulty-option" data-difficulty="baby" onclick="selectDifficulty('baby')">Baby</div>
                <div class="difficulty-option" data-difficulty="easy" onclick="selectDifficulty('easy')">Easy</div>
                <div class="difficulty-option selected" data-difficulty="medium" onclick="selectDifficulty('medium')">Medium</div>
                <div class="difficulty-option" data-difficulty="hard" onclick="selectDifficulty('hard')">Hard</div>
                <div class="difficulty-option" data-difficulty="space" onclick="selectDifficulty('space')">Space</div>
            </div>
        </div>
        <div class="menu-buttons">
            <button class="menu-btn play-btn" onclick="startGame()">Play Solo</button>
            <button class="menu-btn multiplayer-btn" onclick="openMultiplayerLobby()">Multiplayer</button>
            <button class="menu-btn settings-btn" onclick="openSettings()">Settings</button>
        </div>
        <div class="menu-footer">
            <p class="dedication">This game was inspired by the amazing ideas of Claire & Owen Rowe.<br>With love, from Uncle Lei</p>
            <p class="copyright">© Lei Tian | tkltian@gmail.com</p>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-overlay" onclick="closeSettings()"></div>
    <div id="settings-panel">
        <h2>Game Settings</h2>

        <div class="setting-group">
            <label>Difficulty</label>
            <div class="setting-options">
                <div class="setting-option" data-setting="difficulty" data-value="baby">Baby</div>
                <div class="setting-option" data-setting="difficulty" data-value="easy">Easy</div>
                <div class="setting-option selected" data-setting="difficulty" data-value="medium">Medium</div>
                <div class="setting-option" data-setting="difficulty" data-value="hard">Hard</div>
                <div class="setting-option" data-setting="difficulty" data-value="space">Space</div>
            </div>
        </div>

        <div class="setting-group">
            <label>Obstacle Type</label>
            <div class="setting-options">
                <div class="setting-option" data-setting="obstacleType" data-value="cones">
                    <div class="obstacle-preview">
                        <div class="obstacle-icon" style="background: linear-gradient(#ff6600, #ffff00);"></div>
                        Cones
                    </div>
                </div>
                <div class="setting-option" data-setting="obstacleType" data-value="crates">
                    <div class="obstacle-preview">
                        <div class="obstacle-icon" style="background: #8B4513; border-radius: 3px;"></div>
                        Crates
                    </div>
                </div>
                <div class="setting-option selected" data-setting="obstacleType" data-value="labubu">
                    <div class="obstacle-preview">
                        <div class="obstacle-icon" style="background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);"></div>
                        Labubu
                    </div>
                </div>
            </div>
        </div>

        <button class="close-settings" onclick="closeSettings()">Save & Close</button>
    </div>

    <!-- Multiplayer Lobby -->
    <div id="multiplayer-overlay" onclick="closeMultiplayerLobby()"></div>
    <div id="multiplayer-lobby">
        <h2>Multiplayer</h2>

        <div id="mp-initial" class="mp-section">
            <p>Race against a friend on the same network!</p>
            <div class="mp-buttons">
                <button class="mp-btn host-btn" onclick="hostGame()">Host Game</button>
                <button class="mp-btn join-btn" onclick="showJoinInput()">Join Game</button>
            </div>
        </div>

        <div id="mp-hosting" class="mp-section" style="display: none;">
            <p>Share this code with your friend:</p>
            <div id="room-code">----</div>
            <p class="mp-status" id="host-status">Waiting for player to join...</p>
            <button class="mp-btn cancel-btn" onclick="cancelMultiplayer()">Cancel</button>
        </div>

        <div id="mp-joining" class="mp-section" style="display: none;">
            <p>Enter the room code:</p>
            <input type="text" id="join-code-input" placeholder="Enter code" maxlength="6" />
            <div class="mp-buttons">
                <button class="mp-btn join-btn" onclick="joinGame()">Join</button>
                <button class="mp-btn cancel-btn" onclick="cancelMultiplayer()">Cancel</button>
            </div>
            <p class="mp-status" id="join-status"></p>
        </div>

        <div id="mp-connected" class="mp-section" style="display: none;">
            <p class="mp-connected-msg">Connected! Ready to race!</p>
            <p id="opponent-name">Opponent connected</p>
            <button class="mp-btn start-btn" onclick="startMultiplayerGame()">Start Race</button>
            <button class="mp-btn cancel-btn" onclick="cancelMultiplayer()">Leave</button>
        </div>

        <button class="close-settings" onclick="closeMultiplayerLobby()">Close</button>
    </div>

    <!-- Game Container -->
    <div id="game-container"></div>
    <div id="ui">
        <div id="speedometer">0 MPH</div>
        <div id="timer">Time: 0.00s</div>
        <div id="lap">Progress: 0%</div>
    </div>
    <div id="health-container">
        <div id="health-label">HEALTH</div>
        <div id="health-bar-bg">
            <div id="health-bar"></div>
        </div>
    </div>
    <div id="message"></div>
    <div id="instructions">
        Arrow Keys: UP = Accelerate | DOWN = Brake | LEFT/RIGHT = Steer<br>
        Press SPACE to restart | ESC for menu
    </div>
    <button id="back-btn" onclick="goToMenu()">Menu</button>
    <div id="minimap-container">
        <canvas id="minimap"></canvas>
        <div id="minimap-label">Map</div>
    </div>
    <div id="collision-flash"></div>

    <!-- Mobile Touch Controls -->
    <div id="touch-controls">
        <div class="touch-btn" id="touch-left">◀</div>
        <div class="touch-btn" id="touch-right">▶</div>
        <div class="touch-btn" id="touch-accel">▲</div>
        <div class="touch-btn" id="touch-brake">▼</div>
        <div class="touch-btn" id="touch-restart">↻</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // Game Settings
        let gameSettings = {
            difficulty: 'medium',
            obstacleType: 'labubu',
            trackLayout: 'serpentine'
        };

        // Fixed track length (medium)
        const TRACK_LENGTH = 2400;

        // Labubu colors based on Pop Mart "Big Into Energy" series
        // Secret (black) is rare: 1/36 probability
        // Other colors: 35/36 divided by 6 each
        const LABUBU_COLORS = [
            { name: 'Love', color: 0xff6b6b, gradient: 0xff8e8e, ringColor: 0xff6b6b },
            { name: 'Happiness', color: 0xffa502, gradient: 0xffc048, ringColor: 0xffa502 },
            { name: 'Loyalty', color: 0xfd79a8, gradient: 0xfdcb6e, ringColor: 0xfd79a8 },
            { name: 'Serenity', color: 0x00b894, gradient: 0x55efc4, ringColor: 0x00b894 },
            { name: 'Hope', color: 0x0984e3, gradient: 0x74b9ff, ringColor: 0x0984e3 },
            { name: 'Luck', color: 0x6c5ce7, gradient: 0xa29bfe, ringColor: 0x6c5ce7 }
        ];
        // Secret black Labubu - rare limited edition!
        const LABUBU_SECRET = { name: 'Secret', color: 0x1a1a1a, gradient: 0x444444, ringColor: 0xffd700 };

        function getRandomLabubuColor() {
            // Roll 1-36 (inclusive) - only 1 is Secret
            const roll = Math.floor(Math.random() * 36) + 1;
            if (roll === 1) {
                // 1/36 chance (~2.8%) for Secret black Labubu - very rare!
                console.log('RARE! Secret Labubu appeared!');
                return LABUBU_SECRET;
            } else {
                // 35/36 chance divided among 6 colors
                const colorIndex = Math.floor(Math.random() * 6);
                return LABUBU_COLORS[colorIndex];
            }
        }

        // Game constants
        const TRACK_WIDTH = 30;
        const WALL_HEIGHT = 5;
        const CAR_MAX_SPEED = 2;
        const CAR_ACCELERATION = 0.02;
        const CAR_BRAKE_FORCE = 0.04;
        const CAR_FRICTION = 0.005;
        const CAR_TURN_SPEED = 0.01;
        const COLLISION_SLOWDOWN = 0.3;
        const MAX_HEALTH = 100;
        const COLLISION_DAMAGE = 15;
        const GRAVITY = 0.008;
        const JUMP_VELOCITY = 0.65;  // Big bounces! (doubled + 30% more)

        // Game state
        let scene, camera, renderer;
        let car = {
            speed: 0,
            position: null,
            rotation: 0,
            mesh: null,
            velocityY: 0,
            isJumping: false,
            onRamp: false,
            wasColliding: false,  // Track if we were already colliding (for one-time damage)
            currentPadIndex: -1,  // Track which pad car is on (-1 = none) to prevent repeated launches
            canReverse: true      // Must release brake after stopping before reversing
        };
        let keys = {};
        let touchKeys = {};
        let obstacles = [];
        let ramps = [];
        let walls = [];
        let gameTime = 0;
        let gameStarted = false;
        let gameFinished = false;
        let gameOver = false;
        let lastCollisionTime = 0;
        let gameInitialized = false;
        let animationId = null;
        let health = MAX_HEALTH;

        // Audio system for engine and brake sounds
        let audioContext = null;
        let engineOscillator = null;
        let engineGain = null;
        let brakeOscillator = null;
        let brakeGain = null;
        let audioInitialized = false;

        function initAudio() {
            if (audioInitialized) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Engine sound - sawtooth wave for that engine rumble
                engineOscillator = audioContext.createOscillator();
                engineOscillator.type = 'sawtooth';
                engineOscillator.frequency.value = 80;

                engineGain = audioContext.createGain();
                engineGain.gain.value = 0;

                // Add some filtering to make it sound more like an engine
                const engineFilter = audioContext.createBiquadFilter();
                engineFilter.type = 'lowpass';
                engineFilter.frequency.value = 300;

                engineOscillator.connect(engineFilter);
                engineFilter.connect(engineGain);
                engineGain.connect(audioContext.destination);
                engineOscillator.start();

                // Brake sound - noise-like screech
                brakeOscillator = audioContext.createOscillator();
                brakeOscillator.type = 'square';
                brakeOscillator.frequency.value = 200;

                brakeGain = audioContext.createGain();
                brakeGain.gain.value = 0;

                const brakeFilter = audioContext.createBiquadFilter();
                brakeFilter.type = 'highpass';
                brakeFilter.frequency.value = 800;

                brakeOscillator.connect(brakeFilter);
                brakeFilter.connect(brakeGain);
                brakeGain.connect(audioContext.destination);
                brakeOscillator.start();

                audioInitialized = true;
            } catch (e) {
                console.log('Audio not supported:', e);
            }
        }

        function updateEngineSound() {
            if (!audioInitialized || !engineOscillator) return;

            const speedRatio = Math.abs(car.speed) / CAR_MAX_SPEED;
            // Frequency increases with speed (80Hz idle to 250Hz at max speed)
            const targetFreq = 80 + speedRatio * 170;
            engineOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.1);

            // Volume based on whether accelerating and speed
            const isAccelerating = isKeyPressed('ArrowUp');
            const baseVolume = isAccelerating ? 0.08 : 0.03;
            const targetVolume = speedRatio > 0.01 ? baseVolume + speedRatio * 0.04 : 0;
            engineGain.gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.1);
        }

        function updateBrakeSound() {
            if (!audioInitialized || !brakeOscillator) return;

            const isBraking = isKeyPressed('ArrowDown') && car.speed > 0.3;
            const targetVolume = isBraking ? 0.03 : 0;
            brakeGain.gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.05);

            // Vary brake screech pitch slightly
            if (isBraking) {
                brakeOscillator.frequency.setTargetAtTime(200 + Math.random() * 100, audioContext.currentTime, 0.1);
            }
        }

        function stopAllSounds() {
            if (engineGain) engineGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
            if (brakeGain) brakeGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
        }

        // Detect mobile/tablet (including iPads which report as desktop in Safari)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            || window.innerWidth <= 768
            || (navigator.maxTouchPoints > 0 && /MacIntel/.test(navigator.platform))  // iPad reporting as Mac
            || ('ontouchstart' in window && navigator.maxTouchPoints > 1);  // Touch device with multitouch

        // Settings UI handlers
        document.querySelectorAll('.setting-option').forEach(option => {
            option.addEventListener('click', () => {
                const setting = option.dataset.setting;
                const value = option.dataset.value;
                document.querySelectorAll(`[data-setting="${setting}"]`).forEach(opt => {
                    opt.classList.remove('selected');
                });
                option.classList.add('selected');
                gameSettings[setting] = value;
            });
        });

        // Touch controls setup
        function setupTouchControls() {
            const touchButtons = {
                'touch-left': 'ArrowLeft',
                'touch-right': 'ArrowRight',
                'touch-accel': 'ArrowUp',
                'touch-brake': 'ArrowDown'
            };

            Object.entries(touchButtons).forEach(([id, key]) => {
                const btn = document.getElementById(id);

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchKeys[key] = true;
                    btn.classList.add('active');
                    if (!gameStarted && !gameOver) {
                        gameStarted = true;
                        document.getElementById('message').style.display = 'none';
                    }
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touchKeys[key] = false;
                    btn.classList.remove('active');
                });

                btn.addEventListener('touchcancel', (e) => {
                    touchKeys[key] = false;
                    btn.classList.remove('active');
                });
            });

            // Restart button
            document.getElementById('touch-restart').addEventListener('touchstart', (e) => {
                e.preventDefault();
                restartGame();
            });
        }

        function openSettings() {
            document.getElementById('settings-panel').style.display = 'block';
            document.getElementById('settings-overlay').style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settings-panel').style.display = 'none';
            document.getElementById('settings-overlay').style.display = 'none';
        }

        // ============== MULTIPLAYER ==============
        let peer = null;
        let conn = null;
        let isHost = false;
        let multiplayerActive = false;
        let opponentCar = null;
        let opponentData = { x: 0, z: 0, rotation: 0, progress: 0 };
        let opponentFinishTime = null;
        let isPenaltyActive = false;

        // ICE servers for WebRTC NAT traversal
        const peerConfig = {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' }
                ]
            },
            debug: 2
        };

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function openMultiplayerLobby() {
            document.getElementById('multiplayer-lobby').style.display = 'block';
            document.getElementById('multiplayer-overlay').style.display = 'block';
            // Reset to initial state
            document.getElementById('mp-initial').style.display = 'block';
            document.getElementById('mp-hosting').style.display = 'none';
            document.getElementById('mp-joining').style.display = 'none';
            document.getElementById('mp-connected').style.display = 'none';
        }

        function closeMultiplayerLobby() {
            document.getElementById('multiplayer-lobby').style.display = 'none';
            document.getElementById('multiplayer-overlay').style.display = 'none';
            // Clean up peer if not connected
            if (peer && !conn) {
                peer.destroy();
                peer = null;
            }
        }

        function hostGame() {
            const roomCode = generateRoomCode();
            document.getElementById('room-code').textContent = roomCode;
            document.getElementById('host-status').textContent = 'Waiting for player to join...';

            document.getElementById('mp-initial').style.display = 'none';
            document.getElementById('mp-hosting').style.display = 'block';

            // Create peer with room code as ID and ICE config
            peer = new Peer('rapid-racing-' + roomCode, peerConfig);
            isHost = true;

            peer.on('open', function(id) {
                console.log('Host peer ready with ID:', id);
            });

            peer.on('connection', function(connection) {
                conn = connection;
                console.log('Incoming connection...');
                document.getElementById('host-status').textContent = 'Player connecting...';

                conn.on('open', function() {
                    console.log('Connection open!');
                    document.getElementById('host-status').textContent = 'Player connected!';
                    setupConnection();

                    // Show connected state
                    setTimeout(() => {
                        document.getElementById('mp-hosting').style.display = 'none';
                        document.getElementById('mp-connected').style.display = 'block';
                    }, 500);
                });

                conn.on('error', function(err) {
                    console.error('Host connection error:', err);
                    document.getElementById('host-status').textContent = 'Connection error. Try again.';
                });
            });

            peer.on('error', function(err) {
                console.error('Peer error:', err);
                document.getElementById('host-status').textContent = 'Error: ' + err.type;
            });
        }

        function showJoinInput() {
            document.getElementById('mp-initial').style.display = 'none';
            document.getElementById('mp-joining').style.display = 'block';
            document.getElementById('join-code-input').value = '';
            document.getElementById('join-code-input').focus();
        }

        function joinGame() {
            const code = document.getElementById('join-code-input').value.toUpperCase().trim();
            if (code.length !== 4) {
                document.getElementById('join-status').textContent = 'Please enter a 4-character code';
                return;
            }

            document.getElementById('join-status').textContent = 'Connecting...';

            // Create peer for joining with ICE config
            peer = new Peer(peerConfig);
            isHost = false;

            peer.on('open', function(id) {
                console.log('Join peer ready with ID:', id);
                // Connect to host with reliable option
                conn = peer.connect('rapid-racing-' + code, { reliable: true });

                if (!conn) {
                    document.getElementById('join-status').textContent = 'Could not create connection.';
                    return;
                }

                conn.on('open', function() {
                    console.log('Connected to host!');
                    setupConnection();

                    document.getElementById('mp-joining').style.display = 'none';
                    document.getElementById('mp-connected').style.display = 'block';
                });

                conn.on('error', function(err) {
                    console.error('Connection error:', err);
                    document.getElementById('join-status').textContent = 'Connection failed. Try again.';
                });

                // Add timeout for connection
                setTimeout(function() {
                    if (conn && !conn.open) {
                        document.getElementById('join-status').textContent = 'Connection timed out. Check the code and try again.';
                        conn.close();
                    }
                }, 10000);
            });

            peer.on('error', function(err) {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    document.getElementById('join-status').textContent = 'Room not found. Check the code.';
                } else {
                    document.getElementById('join-status').textContent = 'Error: ' + err.type;
                }
            });
        }

        function setupConnection() {
            multiplayerActive = true;

            conn.on('data', function(data) {
                if (data.type === 'position') {
                    opponentData = data;
                    updateOpponentCar();
                } else if (data.type === 'start') {
                    // Other player started the game
                    if (!gameStarted) {
                        startMultiplayerRace();
                    }
                } else if (data.type === 'finish') {
                    // Opponent finished
                    showOpponentFinished(data.time);
                }
            });

            conn.on('close', function() {
                console.log('Connection closed');
                multiplayerActive = false;
                if (gameStarted && !gameFinished) {
                    const msg = document.getElementById('message');
                    msg.innerHTML = '<span style="color: #ff6b6b;">Opponent disconnected!</span>';
                    msg.style.display = 'block';
                    setTimeout(() => {
                        if (!gameFinished) msg.style.display = 'none';
                    }, 3000);
                }
            });
        }

        function cancelMultiplayer() {
            if (conn) {
                conn.close();
                conn = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            multiplayerActive = false;
            isHost = false;
            closeMultiplayerLobby();
        }

        function startMultiplayerGame() {
            // Send start signal to opponent
            if (conn && conn.open) {
                conn.send({ type: 'start' });
            }
            startMultiplayerRace();
        }

        function startMultiplayerRace() {
            closeMultiplayerLobby();
            startGame();
            createOpponentCar();
        }

        function createOpponentCar() {
            // Create a ghost-like opponent car
            const opponentGroup = new THREE.Group();

            // Semi-transparent body
            const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 4);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            opponentGroup.add(body);

            // Cabin
            const cabinGeometry = new THREE.BoxGeometry(1.6, 0.6, 2);
            const cabinMaterial = new THREE.MeshPhongMaterial({
                color: 0x00aaaa,
                transparent: true,
                opacity: 0.5
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 0.9, -0.3);
            opponentGroup.add(cabin);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.7
            });
            const wheelPositions = [
                [-0.9, 0.35, 1.2], [0.9, 0.35, 1.2],
                [-0.9, 0.35, -1.2], [0.9, 0.35, -1.2]
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                opponentGroup.add(wheel);
            });

            opponentCar = opponentGroup;
            scene.add(opponentCar);
        }

        function updateOpponentCar() {
            if (opponentCar && opponentData) {
                opponentCar.position.x = opponentData.x;
                opponentCar.position.z = opponentData.z;
                opponentCar.position.y = opponentData.y || 1;
                opponentCar.rotation.y = opponentData.rotation;
            }
        }

        function sendPositionUpdate() {
            if (conn && conn.open && multiplayerActive && gameStarted && !gameFinished) {
                conn.send({
                    type: 'position',
                    x: car.position.x,
                    z: car.position.z,
                    y: car.position.y,
                    rotation: car.rotation,
                    progress: car.progress
                });
            }
        }

        function showOpponentFinished(time) {
            opponentFinishTime = time;
            const opponentTimeStr = time.toFixed(2);

            if (gameFinished) {
                // We already finished, update the message with final results
                const msg = document.getElementById('message');
                const restartHint = isMobile ? 'Tap ↺ to restart' : 'Press SPACE to restart';
                let resultText = `FINISH!<br>Your Time: ${gameTime.toFixed(2)}s`;

                if (gameTime < opponentFinishTime) {
                    resultText += `<br><span style="color: #ffd700; font-size: 36px;">YOU WIN!</span>`;
                } else if (gameTime > opponentFinishTime) {
                    resultText += `<br><span style="color: #ff6b6b; font-size: 28px;">Opponent wins!</span>`;
                } else {
                    resultText += `<br><span style="color: #feca57; font-size: 28px;">It's a TIE!</span>`;
                }
                resultText += `<br><span style="font-size: 20px;">Opponent: ${opponentTimeStr}s</span>`;
                resultText += `<br><span style="font-size: 24px">${restartHint}</span>`;

                msg.innerHTML = resultText;
            } else {
                // Show brief message that opponent finished (we're still racing)
                const msg = document.getElementById('message');
                msg.innerHTML = `<span style="color: #00ffff;">Opponent finished: ${opponentTimeStr}s</span>`;
                msg.style.display = 'block';
                msg.style.fontSize = '28px';
                setTimeout(() => {
                    if (!gameFinished) {
                        msg.style.display = 'none';
                    }
                }, 3000);
            }
        }

        function selectTrack(track) {
            gameSettings.trackLayout = track;
            document.querySelectorAll('.track-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.track === track) {
                    opt.classList.add('selected');
                }
            });
        }

        function selectDifficulty(difficulty) {
            gameSettings.difficulty = difficulty;
            // Update menu difficulty options
            document.querySelectorAll('.difficulty-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.difficulty === difficulty) {
                    opt.classList.add('selected');
                }
            });
            // Also update settings panel if open
            document.querySelectorAll('.setting-option[data-setting="difficulty"]').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.value === difficulty) {
                    opt.classList.add('selected');
                }
            });
        }

        function getTrackCurves(layout) {
            if (layout === 'classic') {
                return [
                    { start: 0.12, end: 0.22, rate: 0.06 },
                    { start: 0.32, end: 0.42, rate: -0.07 },
                    { start: 0.55, end: 0.65, rate: 0.06 },
                    { start: 0.75, end: 0.85, rate: -0.06 },
                ];
            } else if (layout === 'serpentine') {
                return [
                    { start: 0.06, end: 0.13, rate: 0.12 },
                    { start: 0.17, end: 0.24, rate: -0.14 },
                    { start: 0.28, end: 0.35, rate: 0.13 },
                    { start: 0.40, end: 0.47, rate: -0.14 },
                    { start: 0.52, end: 0.59, rate: 0.12 },
                    { start: 0.64, end: 0.71, rate: -0.13 },
                    { start: 0.76, end: 0.83, rate: 0.12 },
                    { start: 0.88, end: 0.94, rate: -0.10 },
                ];
            } else if (layout === 'zigzag') {
                return [
                    { start: 0.08, end: 0.14, rate: 0.22 },
                    { start: 0.20, end: 0.26, rate: -0.24 },
                    { start: 0.32, end: 0.38, rate: 0.22 },
                    { start: 0.44, end: 0.50, rate: -0.24 },
                    { start: 0.56, end: 0.62, rate: 0.22 },
                    { start: 0.68, end: 0.74, rate: -0.24 },
                    { start: 0.80, end: 0.86, rate: 0.22 },
                    { start: 0.91, end: 0.96, rate: -0.18 },
                ];
            } else if (layout === 'spiral') {
                return [
                    { start: 0.05, end: 0.45, rate: 0.08 },
                    { start: 0.50, end: 0.55, rate: -0.15 },
                    { start: 0.60, end: 0.95, rate: -0.07 },
                ];
            } else if (layout === 'hairpin') {
                return [
                    { start: 0.12, end: 0.22, rate: 0.45 },
                    { start: 0.32, end: 0.42, rate: -0.45 },
                    { start: 0.52, end: 0.62, rate: 0.45 },
                    { start: 0.72, end: 0.82, rate: -0.45 },
                    { start: 0.90, end: 0.96, rate: 0.25 },
                ];
            } else if (layout === 'insane') {
                return [
                    { start: 0.02, end: 0.09, rate: 0.35 },
                    { start: 0.10, end: 0.17, rate: -0.40 },
                    { start: 0.18, end: 0.25, rate: 0.38 },
                    { start: 0.26, end: 0.33, rate: -0.42 },
                    { start: 0.34, end: 0.41, rate: 0.40 },
                    { start: 0.42, end: 0.49, rate: -0.38 },
                    { start: 0.50, end: 0.57, rate: 0.42 },
                    { start: 0.58, end: 0.65, rate: -0.40 },
                    { start: 0.66, end: 0.73, rate: 0.38 },
                    { start: 0.74, end: 0.81, rate: -0.42 },
                    { start: 0.82, end: 0.89, rate: 0.35 },
                    { start: 0.90, end: 0.97, rate: -0.30 },
                ];
            } else if (layout === 'grandprix') {
                // 2x longer: F1-style with chicanes, sweepers, and straights
                return [
                    // Straight then tight chicane
                    { start: 0.06, end: 0.09, rate: 0.30 },   // Sharp right
                    { start: 0.10, end: 0.13, rate: -0.35 },  // Sharp left
                    // Long sweeping right
                    { start: 0.18, end: 0.28, rate: 0.06 },   // Wide sweeper
                    // Straight section (no curves 0.28-0.34)
                    // Tight hairpin
                    { start: 0.35, end: 0.42, rate: -0.38 },  // Tight left hairpin
                    // Medium right curve
                    { start: 0.47, end: 0.53, rate: 0.12 },   // Medium right
                    // Another chicane
                    { start: 0.58, end: 0.61, rate: -0.28 },  // Quick left
                    { start: 0.62, end: 0.65, rate: 0.30 },   // Quick right
                    // Long sweeping left
                    { start: 0.70, end: 0.80, rate: -0.05 },  // Wide sweeper left
                    // Final tight section
                    { start: 0.85, end: 0.90, rate: 0.25 },   // Tight right
                    { start: 0.93, end: 0.97, rate: -0.15 },  // Medium left to finish
                ];
            } else if (layout === 'mountain') {
                // 2x longer: Mountain switchback road with U-turns
                // Designed like real mountain roads - each switchback is offset so track doesn't cross
                return [
                    // Start with gentle right to set up the pattern
                    { start: 0.02, end: 0.06, rate: 0.08 },   // ~25° setup right
                    // First U-turn right (~160°) - switchback #1
                    { start: 0.09, end: 0.19, rate: 0.25 },   // ~160° U-turn right
                    // Straight section heading back (offset from start)
                    // Sharp left to add variety
                    { start: 0.24, end: 0.28, rate: -0.18 },  // ~46° sharp left
                    // Second U-turn left (~155°) - switchback #2
                    { start: 0.32, end: 0.42, rate: -0.24 },  // ~155° U-turn left
                    // Sweeping section
                    { start: 0.47, end: 0.53, rate: 0.07 },   // ~27° gentle sweeper right
                    // Third U-turn right (~150°) - switchback #3
                    { start: 0.57, end: 0.67, rate: 0.23 },   // ~150° U-turn right
                    // Sharp left for variety
                    { start: 0.71, end: 0.75, rate: -0.20 },  // ~51° sharp left
                    // Fourth U-turn left (~140°) - final switchback
                    { start: 0.79, end: 0.88, rate: -0.22 },  // ~140° U-turn left
                    // Exit sweeper to finish
                    { start: 0.92, end: 0.98, rate: 0.10 },   // ~38° gentle right to finish
                ];
            } else if (layout === 'coastal') {
                // 2x longer: Flowing coastal road with varying curves
                return [
                    // Opening sweeper
                    { start: 0.03, end: 0.10, rate: 0.09 },   // Wide right
                    // Tight cove turn
                    { start: 0.14, end: 0.19, rate: -0.22 },  // Sharp left
                    // Long coastal sweep
                    { start: 0.24, end: 0.36, rate: 0.045 },  // Very wide right
                    // Quick direction changes
                    { start: 0.40, end: 0.44, rate: -0.18 },  // Medium left
                    { start: 0.46, end: 0.50, rate: 0.16 },   // Medium right
                    // Cliffside hairpin
                    { start: 0.55, end: 0.63, rate: -0.35 },  // Tight hairpin left
                    // Flowing S-section
                    { start: 0.68, end: 0.73, rate: 0.10 },   // Medium right
                    { start: 0.75, end: 0.80, rate: -0.11 },  // Medium left
                    { start: 0.82, end: 0.87, rate: 0.09 },   // Medium right
                    // Final approach
                    { start: 0.92, end: 0.97, rate: -0.07 },  // Gentle left to finish
                ];
            } else if (layout === 'championship') {
                // 2x longer: Ultimate challenge - everything combined
                return [
                    // Fast chicane start
                    { start: 0.03, end: 0.06, rate: 0.32 },   // Sharp right
                    { start: 0.07, end: 0.10, rate: -0.35 },  // Sharp left
                    // Sweeping right
                    { start: 0.14, end: 0.22, rate: 0.07 },   // Wide right
                    // Double hairpin
                    { start: 0.26, end: 0.32, rate: -0.48 },  // Tight hairpin left
                    { start: 0.36, end: 0.42, rate: 0.46 },   // Tight hairpin right
                    // Long straight (0.42-0.48)
                    // Technical section
                    { start: 0.49, end: 0.52, rate: -0.25 },  // Quick left
                    { start: 0.53, end: 0.57, rate: 0.20 },   // Medium right
                    { start: 0.58, end: 0.61, rate: -0.28 },  // Quick left
                    // Sweeping esses
                    { start: 0.65, end: 0.71, rate: 0.08 },   // Wide right
                    { start: 0.73, end: 0.79, rate: -0.09 },  // Wide left
                    // Final hairpin
                    { start: 0.84, end: 0.91, rate: 0.40 },   // Hairpin right
                    // Sprint to finish
                    { start: 0.95, end: 0.98, rate: -0.12 },  // Medium left
                ];
            }
            return [];
        }

        // Tracks that are 2x longer
        const LONG_TRACKS = ['grandprix', 'mountain', 'coastal', 'championship'];

        function getTrackLength(layout) {
            return LONG_TRACKS.includes(layout) ? 3200 : 1600;
        }

        function generatePreviewWaypoints(layout) {
            const waypoints = [];
            const segmentLength = 25;
            const trackLen = getTrackLength(layout);
            const numSegments = Math.ceil(trackLen / segmentLength);
            let x = 0, z = 0, angle = 0;
            const curves = getTrackCurves(layout);

            function getTurnRate(progress) {
                for (const curve of curves) {
                    if (progress >= curve.start && progress < curve.end) {
                        return curve.rate;
                    }
                }
                return 0;
            }

            for (let i = 0; i <= numSegments; i++) {
                waypoints.push({ x, z });
                const progress = i / numSegments;
                const turnRate = getTurnRate(progress);
                angle += turnRate;
                x += Math.sin(angle) * segmentLength;
                z -= Math.cos(angle) * segmentLength;
            }
            return waypoints;
        }

        function drawTrackPreview(layout, canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width = 55;
            const height = canvas.height = 55;

            // Generate waypoints for this layout
            const waypoints = generatePreviewWaypoints(layout);

            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            for (const wp of waypoints) {
                minX = Math.min(minX, wp.x);
                maxX = Math.max(maxX, wp.x);
                minZ = Math.min(minZ, wp.z);
                maxZ = Math.max(maxZ, wp.z);
            }

            // Add padding and calculate scale
            const padding = 5;
            const trackWidth = maxX - minX;
            const trackHeight = maxZ - minZ;
            const scaleX = (width - padding * 2) / (trackWidth || 1);
            const scaleZ = (height - padding * 2) / (trackHeight || 1);
            const scale = Math.min(scaleX, scaleZ);

            // Center offset
            const offsetX = (width - trackWidth * scale) / 2 - minX * scale;
            const offsetZ = (height - trackHeight * scale) / 2 - minZ * scale;

            // Clear canvas
            ctx.fillStyle = 'rgba(20, 20, 35, 0.9)';
            ctx.fillRect(0, 0, width, height);

            // Draw track
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let i = 0; i < waypoints.length; i++) {
                const x = waypoints[i].x * scale + offsetX;
                const z = waypoints[i].z * scale + offsetZ;
                if (i === 0) {
                    ctx.moveTo(x, z);
                } else {
                    ctx.lineTo(x, z);
                }
            }
            ctx.stroke();

            // Draw start point (green)
            const startX = waypoints[0].x * scale + offsetX;
            const startZ = waypoints[0].z * scale + offsetZ;
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(startX, startZ, 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw finish point (red)
            const endWp = waypoints[waypoints.length - 1];
            const endX = endWp.x * scale + offsetX;
            const endZ = endWp.z * scale + offsetZ;
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(endX, endZ, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawAllTrackPreviews() {
            const layouts = ['classic', 'serpentine', 'zigzag', 'spiral', 'hairpin', 'insane', 'grandprix', 'mountain', 'coastal', 'championship'];
            layouts.forEach(layout => {
                drawTrackPreview(layout, 'preview-' + layout);
            });
        }

        // Draw track previews when page loads
        document.addEventListener('DOMContentLoaded', drawAllTrackPreviews);

        function startGame() {
            document.body.classList.remove('menu-active');
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('health-container').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('back-btn').style.display = 'block';
            document.getElementById('minimap-container').style.display = 'block';
            if (isMobile) {
                document.getElementById('touch-controls').style.display = 'block';
            }

            // Initialize audio on user interaction (required by browsers)
            initAudio();

            if (gameInitialized) {
                cleanupGame();
            }
            init();
        }

        function goToMenu() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            stopAllSounds();

            // Clean up multiplayer
            if (opponentCar && scene) {
                scene.remove(opponentCar);
                opponentCar = null;
            }
            opponentFinishTime = null;
            isPenaltyActive = false;
            // Keep connection alive if still connected

            document.getElementById('game-container').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('health-container').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('back-btn').style.display = 'none';
            document.getElementById('message').style.display = 'none';
            document.getElementById('touch-controls').style.display = 'none';
            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('home-page').style.display = 'flex';
            document.body.classList.add('menu-active');
        }

        function cleanupGame() {
            const container = document.getElementById('game-container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            obstacles = [];
            ramps = [];
            walls = [];
            if (scene) {
                scene.traverse((object) => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(m => m.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            if (renderer) {
                renderer.dispose();
            }
        }

        function init() {
            gameInitialized = true;
            health = MAX_HEALTH;
            updateHealthBar();

            car.position = new THREE.Vector3(0, 1, 0);
            car.rotation = 0;
            car.speed = 0;
            car.velocityY = 0;
            car.isJumping = false;
            car.onRamp = false;
            carTrackIndex = 0; // Reset track progress
            car.wasColliding = false;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            createTrack();
            createCar();
            createRamps();
            createObstacles();
            createFinishLine();
            createScenery();

            // Set initial camera position behind the car
            const cameraOffset = new THREE.Vector3(0, 1.5, 0.5);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
            camera.position.copy(car.position).add(cameraOffset);
            camera.rotation.y = car.rotation;

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', onWindowResize);
            setupTouchControls();

            const message = document.getElementById('message');
            message.innerHTML = isMobile ? 'READY!<br>Touch controls to Start' : 'READY!<br>Press Arrow Keys to Start';
            message.style.display = 'block';
            message.style.color = '#ffff00';

            gameTime = 0;
            gameStarted = false;
            gameFinished = false;
            gameOver = false;

            lastTime = 0;
            animate(0);
        }

        function handleKeyDown(e) {
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Escape'].includes(e.code)) {
                e.preventDefault();
            }
            keys[e.code] = true;
            if (e.code === 'Escape') {
                goToMenu();
                return;
            }
            if (e.code === 'Space') {
                restartGame();
            }
            if (!gameStarted && !gameOver && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                gameStarted = true;
                document.getElementById('message').style.display = 'none';
            }
        }

        function handleKeyUp(e) {
            keys[e.code] = false;
        }

        function isKeyPressed(key) {
            return keys[key] || touchKeys[key];
        }

        // Track waypoints for curved path
        let trackWaypoints = [];
        let smoothTrackPoints = []; // Smooth spline points for collision and minimap
        let carTrackIndex = 0; // Track car's progress along the track (segment index)

        // Check if two line segments intersect
        function segmentsIntersect(p1, p2, p3, p4) {
            const d1 = direction(p3, p4, p1);
            const d2 = direction(p3, p4, p2);
            const d3 = direction(p1, p2, p3);
            const d4 = direction(p1, p2, p4);

            if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
                return true;
            }
            return false;
        }

        function direction(p1, p2, p3) {
            return (p3.x - p1.x) * (p2.z - p1.z) - (p2.x - p1.x) * (p3.z - p1.z);
        }

        // Check if track self-intersects (skip adjacent segments)
        function checkTrackIntersection(waypoints) {
            const minGap = 15; // Minimum segment gap to check (skip nearby segments)
            for (let i = 0; i < waypoints.length - 1; i++) {
                for (let j = i + minGap; j < waypoints.length - 1; j++) {
                    if (segmentsIntersect(waypoints[i], waypoints[i+1], waypoints[j], waypoints[j+1])) {
                        console.warn(`Track self-intersection detected between segments ${i} and ${j}`);
                        return true;
                    }
                }
            }
            return false;
        }

        function generateTrackWaypoints() {
            trackWaypoints = [];
            const layout = gameSettings.trackLayout;
            // Use smaller segments for smoother curves
            const segmentLength = 25;
            const trackLen = getTrackLength(layout);
            const numSegments = Math.ceil(trackLen / segmentLength);
            let x = 0, z = 0, angle = 0;

            // Helper: get turn rate based on progress through track
            function getTurnRate(progress, curves) {
                for (const curve of curves) {
                    if (progress >= curve.start && progress < curve.end) {
                        return curve.rate;
                    }
                }
                return 0;
            }

            // Get curves from centralized function
            const curves = getTrackCurves(layout);

            for (let i = 0; i <= numSegments; i++) {
                trackWaypoints.push({ x, z, angle });

                const progress = i / numSegments;
                const turnRate = getTurnRate(progress, curves);
                angle += turnRate;

                // Move forward in current direction
                x += Math.sin(angle) * segmentLength;
                z -= Math.cos(angle) * segmentLength;
            }

            // Validate track doesn't self-intersect
            if (checkTrackIntersection(trackWaypoints)) {
                console.error(`Track layout "${layout}" has self-intersection! Please fix the track design.`);
            }

            return trackWaypoints;
        }

        function getTrackPositionAt(distance) {
            const segmentLength = 25;
            const segmentIndex = Math.floor(distance / segmentLength);
            const segmentProgress = (distance % segmentLength) / segmentLength;

            if (segmentIndex >= trackWaypoints.length - 1) {
                return trackWaypoints[trackWaypoints.length - 1];
            }
            if (segmentIndex < 0) {
                return trackWaypoints[0];
            }

            const wp1 = trackWaypoints[segmentIndex];
            const wp2 = trackWaypoints[segmentIndex + 1];

            return {
                x: wp1.x + (wp2.x - wp1.x) * segmentProgress,
                z: wp1.z + (wp2.z - wp1.z) * segmentProgress,
                angle: wp1.angle + (wp2.angle - wp1.angle) * segmentProgress
            };
        }

        function createTrack() {
            generateTrackWaypoints();

            const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, side: THREE.DoubleSide });
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });

            // Create smooth spline curve from waypoints
            const curvePoints = trackWaypoints.map(wp => new THREE.Vector3(wp.x, 0, wp.z));
            const trackCurve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.5);

            // Sample many points along the smooth curve for rendering
            const numSamples = trackWaypoints.length * 4;
            const sampledPoints = trackCurve.getPoints(numSamples);

            // Store for collision detection and minimap
            smoothTrackPoints = sampledPoints;

            // Create track ribbon geometry
            const trackVertices = [];
            const trackIndices = [];
            const leftEdgePoints = [];
            const rightEdgePoints = [];

            for (let i = 0; i < sampledPoints.length; i++) {
                const point = sampledPoints[i];

                // Calculate direction (tangent) at this point
                let tangent;
                if (i < sampledPoints.length - 1) {
                    tangent = new THREE.Vector3().subVectors(sampledPoints[i + 1], point).normalize();
                } else {
                    tangent = new THREE.Vector3().subVectors(point, sampledPoints[i - 1]).normalize();
                }

                // Perpendicular vector (for track width)
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x);

                // Left and right edge points
                const leftPoint = new THREE.Vector3(
                    point.x + perpendicular.x * TRACK_WIDTH / 2,
                    0,
                    point.z + perpendicular.z * TRACK_WIDTH / 2
                );
                const rightPoint = new THREE.Vector3(
                    point.x - perpendicular.x * TRACK_WIDTH / 2,
                    0,
                    point.z - perpendicular.z * TRACK_WIDTH / 2
                );

                leftEdgePoints.push(leftPoint);
                rightEdgePoints.push(rightPoint);

                // Add vertices (left, right)
                trackVertices.push(leftPoint.x, 0, leftPoint.z);
                trackVertices.push(rightPoint.x, 0, rightPoint.z);
            }

            // Create triangles connecting the vertices
            for (let i = 0; i < sampledPoints.length - 1; i++) {
                const bl = i * 2;      // bottom left
                const br = i * 2 + 1;  // bottom right
                const tl = (i + 1) * 2;     // top left
                const tr = (i + 1) * 2 + 1; // top right

                // Two triangles per quad
                trackIndices.push(bl, br, tl);
                trackIndices.push(br, tr, tl);
            }

            // Create the track mesh
            const trackGeometry = new THREE.BufferGeometry();
            trackGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trackVertices, 3));
            trackGeometry.setIndex(trackIndices);
            trackGeometry.computeVertexNormals();

            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            trackMesh.receiveShadow = true;
            scene.add(trackMesh);

            // Create smooth edge lines using tubes
            const leftCurve = new THREE.CatmullRomCurve3(leftEdgePoints);
            const rightCurve = new THREE.CatmullRomCurve3(rightEdgePoints);

            const edgeLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            const leftTube = new THREE.TubeGeometry(leftCurve, numSamples, 0.3, 4, false);
            const leftLine = new THREE.Mesh(leftTube, edgeLineMaterial);
            leftLine.position.y = 0.05;
            scene.add(leftLine);

            const rightTube = new THREE.TubeGeometry(rightCurve, numSamples, 0.3, 4, false);
            const rightLine = new THREE.Mesh(rightTube, edgeLineMaterial);
            rightLine.position.y = 0.05;
            scene.add(rightLine);

            // Center line dashes
            for (let i = 0; i < sampledPoints.length; i += 8) {
                if (i + 2 >= sampledPoints.length) break;

                const p1 = sampledPoints[i];
                const p2 = sampledPoints[Math.min(i + 2, sampledPoints.length - 1)];

                const dx = p2.x - p1.x;
                const dz = p2.z - p1.z;
                const len = Math.sqrt(dx * dx + dz * dz);
                const angle = Math.atan2(dx, -dz);

                const dashGeometry = new THREE.PlaneGeometry(0.4, Math.min(len * 2, 6));
                const dash = new THREE.Mesh(dashGeometry, lineMaterial);
                dash.rotation.x = -Math.PI / 2;
                dash.rotation.z = -angle;
                dash.position.set(p1.x, 0.02, p1.z);
                scene.add(dash);
            }

            // Store wall segments for collision detection using smooth curve points
            for (let i = 0; i < sampledPoints.length - 1; i++) {
                const p1 = sampledPoints[i];
                const p2 = sampledPoints[i + 1];

                let tangent = new THREE.Vector3().subVectors(p2, p1).normalize();
                const perpX = -tangent.z;
                const perpZ = tangent.x;

                walls.push({
                    x1: p1.x + perpX * TRACK_WIDTH / 2,
                    z1: p1.z + perpZ * TRACK_WIDTH / 2,
                    x2: p2.x + perpX * TRACK_WIDTH / 2,
                    z2: p2.z + perpZ * TRACK_WIDTH / 2,
                    type: 'left'
                });
                walls.push({
                    x1: p1.x - perpX * TRACK_WIDTH / 2,
                    z1: p1.z - perpZ * TRACK_WIDTH / 2,
                    x2: p2.x - perpX * TRACK_WIDTH / 2,
                    z2: p2.z - perpZ * TRACK_WIDTH / 2,
                    type: 'right'
                });
            }

            // Calculate bounds from track waypoints
            let minX = 0, maxX = 0, minZ = 0, maxZ = 0;
            trackWaypoints.forEach(wp => {
                minX = Math.min(minX, wp.x);
                maxX = Math.max(maxX, wp.x);
                minZ = Math.min(minZ, wp.z);
                maxZ = Math.max(maxZ, wp.z);
            });

            // Expand bounds for grass coverage
            const padding = 300;
            minX -= padding;
            maxX += padding;
            minZ -= padding;
            maxZ += padding;

            // Large grass tiles to cover entire track area
            const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const grassGeometry = new THREE.PlaneGeometry(500, 500);

            const startGX = Math.floor(minX / 400) - 1;
            const endGX = Math.ceil(maxX / 400) + 1;
            const startGZ = Math.floor(minZ / 400) - 1;
            const endGZ = Math.ceil(maxZ / 400) + 1;

            for (let gx = startGX; gx <= endGX; gx++) {
                for (let gz = startGZ; gz <= endGZ; gz++) {
                    const grassTile = new THREE.Mesh(grassGeometry, grassMaterial);
                    grassTile.rotation.x = -Math.PI / 2;
                    grassTile.position.set(gx * 400, -0.15, gz * 400);
                    scene.add(grassTile);
                }
            }
        }

        function createCar() {
            const carGeometry = new THREE.BoxGeometry(3, 1.5, 5);
            const carMaterial = new THREE.MeshStandardMaterial({ color: 0x0066ff, transparent: true, opacity: 0 });
            car.mesh = new THREE.Mesh(carGeometry, carMaterial);
            car.mesh.position.copy(car.position);
            scene.add(car.mesh);

            const carColor = 0x0066ff;
            const hoodMaterial = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.6, roughness: 0.4 });

            // Main hood - curved shape using multiple parts
            // Center hood section (slightly raised in middle)
            const hoodCenterGeometry = new THREE.BoxGeometry(1.8, 0.25, 2.8);
            const hoodCenter = new THREE.Mesh(hoodCenterGeometry, hoodMaterial);
            hoodCenter.position.set(0, -0.25, -2.0);
            car.mesh.add(hoodCenter);

            // Hood bulge (gives it a muscle car look)
            const bulgeMaterial = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.7, roughness: 0.3 });
            const hoodBulgeGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.8, 16);
            const hoodBulge = new THREE.Mesh(hoodBulgeGeometry, bulgeMaterial);
            hoodBulge.rotation.x = Math.PI / 2;
            hoodBulge.position.set(0, -0.1, -2.2);
            hoodBulge.scale.set(1, 0.3, 1);
            car.mesh.add(hoodBulge);

            // Left side of hood (sloped down)
            const hoodSideGeometry = new THREE.BoxGeometry(0.5, 0.2, 2.8);
            const hoodLeftSide = new THREE.Mesh(hoodSideGeometry, hoodMaterial);
            hoodLeftSide.position.set(-1.15, -0.35, -2.0);
            hoodLeftSide.rotation.z = 0.15;
            car.mesh.add(hoodLeftSide);

            // Right side of hood (sloped down)
            const hoodRightSide = new THREE.Mesh(hoodSideGeometry, hoodMaterial);
            hoodRightSide.position.set(1.15, -0.35, -2.0);
            hoodRightSide.rotation.z = -0.15;
            car.mesh.add(hoodRightSide);

            // Front edge of hood (curved down)
            const frontEdgeGeometry = new THREE.BoxGeometry(2.4, 0.15, 0.3);
            const frontEdge = new THREE.Mesh(frontEdgeGeometry, hoodMaterial);
            frontEdge.position.set(0, -0.4, -3.4);
            frontEdge.rotation.x = 0.3;
            car.mesh.add(frontEdge);

            // Headlights - sticking out from front
            const headlightGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffee });
            const headlightRimMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });

            // Left headlight
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(-0.9, -0.35, -3.5);
            leftHeadlight.scale.set(1, 0.7, 0.5);
            car.mesh.add(leftHeadlight);

            // Left headlight rim
            const headlightRimGeometry = new THREE.TorusGeometry(0.22, 0.04, 8, 16);
            const leftHeadlightRim = new THREE.Mesh(headlightRimGeometry, headlightRimMaterial);
            leftHeadlightRim.position.set(-0.9, -0.35, -3.52);
            leftHeadlightRim.scale.set(1, 0.7, 1);
            car.mesh.add(leftHeadlightRim);

            // Right headlight
            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(0.9, -0.35, -3.5);
            rightHeadlight.scale.set(1, 0.7, 0.5);
            car.mesh.add(rightHeadlight);

            // Right headlight rim
            const rightHeadlightRim = new THREE.Mesh(headlightRimGeometry, headlightRimMaterial);
            rightHeadlightRim.position.set(0.9, -0.35, -3.52);
            rightHeadlightRim.scale.set(1, 0.7, 1);
            car.mesh.add(rightHeadlightRim);

            // Dashboard
            const dashboardGeometry = new THREE.BoxGeometry(2.6, 0.5, 1.0);
            const dashboardMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const dashboard = new THREE.Mesh(dashboardGeometry, dashboardMaterial);
            dashboard.position.set(0, -0.15, -0.7);
            car.mesh.add(dashboard);

            // Dashboard top (padded look)
            const dashTopGeometry = new THREE.BoxGeometry(2.4, 0.15, 0.6);
            const dashTopMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 });
            const dashTop = new THREE.Mesh(dashTopGeometry, dashTopMaterial);
            dashTop.position.set(0, 0.15, -0.9);
            dashTop.rotation.x = -0.2;
            car.mesh.add(dashTop);

            // Instrument cluster (gauges)
            const instrumentGeometry = new THREE.BoxGeometry(0.7, 0.35, 0.05);
            const instrumentMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const instruments = new THREE.Mesh(instrumentGeometry, instrumentMaterial);
            instruments.position.set(0, 0.1, -1.1);
            instruments.rotation.x = -0.4;
            car.mesh.add(instruments);

            // Speedometer dial
            const dialGeometry = new THREE.CircleGeometry(0.12, 16);
            const dialMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const speedoDial = new THREE.Mesh(dialGeometry, dialMaterial);
            speedoDial.position.set(-0.15, 0.12, -1.08);
            speedoDial.rotation.x = -0.4;
            car.mesh.add(speedoDial);

            // Tach dial
            const tachDial = new THREE.Mesh(dialGeometry, dialMaterial);
            tachDial.position.set(0.15, 0.12, -1.08);
            tachDial.rotation.x = -0.4;
            car.mesh.add(tachDial);

            // Steering wheel
            const steeringWheelGeometry = new THREE.TorusGeometry(0.22, 0.035, 8, 24);
            const steeringWheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const steeringWheel = new THREE.Mesh(steeringWheelGeometry, steeringWheelMaterial);
            steeringWheel.position.set(0, 0.15, -0.55);
            steeringWheel.rotation.x = Math.PI / 3.5;
            car.mesh.add(steeringWheel);

            // Steering wheel spokes
            const spokeMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const spokeGeometry = new THREE.BoxGeometry(0.03, 0.18, 0.03);

            const spoke1 = new THREE.Mesh(spokeGeometry, spokeMaterial);
            spoke1.position.set(0, 0.15, -0.55);
            spoke1.rotation.x = Math.PI / 3.5;
            car.mesh.add(spoke1);

            const spoke2 = new THREE.Mesh(spokeGeometry, spokeMaterial);
            spoke2.position.set(0, 0.15, -0.55);
            spoke2.rotation.x = Math.PI / 3.5;
            spoke2.rotation.z = Math.PI / 2;
            car.mesh.add(spoke2);

            // Steering wheel center hub
            const hubGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16);
            const hubMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.position.set(0, 0.15, -0.55);
            hub.rotation.x = Math.PI / 2 - Math.PI / 3.5;
            car.mesh.add(hub);
        }

        function createRamps() {
            // Create bounce pads at strategic positions along the curved track
            const rampCount = Math.floor(TRACK_LENGTH / 200);

            for (let i = 0; i < rampCount; i++) {
                // Position along the track (use waypoints)
                const trackProgress = (i + 1) / (rampCount + 1);
                const waypointIndex = Math.floor(trackProgress * (trackWaypoints.length - 1));
                const wp = trackWaypoints[waypointIndex];
                const nextWp = trackWaypoints[Math.min(waypointIndex + 1, trackWaypoints.length - 1)];
                const angle = Math.atan2(nextWp.x - wp.x, -(nextWp.z - wp.z));
                const perpX = Math.cos(angle);
                const perpZ = Math.sin(angle);

                // Random offset from center of track
                const lateralOffset = (Math.random() - 0.5) * (TRACK_WIDTH - 10);
                const padX = wp.x + perpX * lateralOffset;
                const padZ = wp.z + perpZ * lateralOffset;
                // Baby mode: 2x bigger launch pads for easier hitting
                const padRadius = gameSettings.difficulty === 'baby' ? 6 : 3;

                const bouncePadGroup = new THREE.Group();

                // Base circle pad (transparent rainbow)
                const padGeometry = new THREE.CylinderGeometry(padRadius, padRadius, 0.3, 32);
                const padMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4
                });
                const pad = new THREE.Mesh(padGeometry, padMaterial);
                pad.position.y = 0.15;
                bouncePadGroup.add(pad);

                // Rainbow ring around the pad
                const ringGeometry = new THREE.TorusGeometry(padRadius, 0.2, 8, 32);
                const rainbowColors = [0xff0000, 0xff7700, 0xffff00, 0x00ff00, 0x0077ff, 0x8800ff];
                rainbowColors.forEach((color, idx) => {
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.6
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = 0.1 + idx * 0.15;
                    ring.scale.set(1 - idx * 0.1, 1 - idx * 0.1, 1);
                    bouncePadGroup.add(ring);
                });

                // Create 3D upward arrow
                const arrowGroup = new THREE.Group();

                // Arrow shaft
                const shaftGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                const shaftMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.7
                });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.position.y = 1.5;
                arrowGroup.add(shaft);

                // Arrow head (cone)
                const headGeometry = new THREE.ConeGeometry(0.8, 1.5, 8);
                const headMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.2;
                arrowGroup.add(head);

                // Add multiple smaller arrows around it for effect
                for (let a = 0; a < 3; a++) {
                    const smallArrow = new THREE.Group();
                    const smallShaft = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.15, 1, 6),
                        new THREE.MeshBasicMaterial({
                            color: rainbowColors[a * 2],
                            transparent: true,
                            opacity: 0.5
                        })
                    );
                    smallShaft.position.y = 1;
                    smallArrow.add(smallShaft);

                    const smallHead = new THREE.Mesh(
                        new THREE.ConeGeometry(0.4, 0.8, 6),
                        new THREE.MeshBasicMaterial({
                            color: rainbowColors[a * 2 + 1],
                            transparent: true,
                            opacity: 0.5
                        })
                    );
                    smallHead.position.y = 1.9;
                    smallArrow.add(smallHead);

                    const angle = (a / 3) * Math.PI * 2;
                    smallArrow.position.x = Math.cos(angle) * 1.5;
                    smallArrow.position.z = Math.sin(angle) * 1.5;
                    arrowGroup.add(smallArrow);
                }

                bouncePadGroup.add(arrowGroup);
                bouncePadGroup.position.set(padX, 0, padZ);
                bouncePadGroup.userData.arrowGroup = arrowGroup;
                scene.add(bouncePadGroup);

                ramps.push({
                    x: padX,
                    z: padZ,
                    radius: padRadius,
                    mesh: bouncePadGroup
                });
            }
        }

        function createObstacles() {
            const obstacleCount = Math.floor(TRACK_LENGTH / 50);
            const obstaclePositions = [];

            // Use smooth track points for obstacle placement
            const points = smoothTrackPoints.length > 0 ? smoothTrackPoints : trackWaypoints;

            // Calculate curvature at each point to avoid placing obstacles at tight turns
            const curvatures = [];
            for (let i = 1; i < points.length - 1; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const next = points[i + 1];

                // Calculate angle change (curvature indicator)
                const angle1 = Math.atan2(curr.x - prev.x, curr.z - prev.z);
                const angle2 = Math.atan2(next.x - curr.x, next.z - curr.z);
                let angleDiff = Math.abs(angle2 - angle1);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                curvatures[i] = angleDiff;
            }
            curvatures[0] = 0;
            curvatures[points.length - 1] = 0;

            // Place obstacles along the curved track, avoiding tight curves
            for (let i = 0; i < obstacleCount; i++) {
                const trackProgress = (i + 0.5) / obstacleCount;
                const pointIndex = Math.floor(trackProgress * (points.length - 2)) + 1;

                // Skip if this is a tight curve (curvature > threshold)
                if (curvatures[pointIndex] > 0.15) continue;

                const p = points[pointIndex];
                const nextP = points[Math.min(pointIndex + 1, points.length - 1)];
                const trackAngle = Math.atan2(nextP.x - p.x, -(nextP.z - p.z));
                const perpX = Math.cos(trackAngle);
                const perpZ = Math.sin(trackAngle);

                // Random offset from center of track (reduced range for safety)
                const lateralOffset = (Math.random() - 0.5) * (TRACK_WIDTH - 10);
                obstaclePositions.push({
                    x: p.x + perpX * lateralOffset,
                    z: p.z + perpZ * lateralOffset
                });
            }

            const difficultyMultiplier = { baby: 0.1, easy: 0.6, medium: 1, hard: 1.5, space: 1.5 };
            // Baby mode: max 4 obstacles, evenly spaced throughout track
            let actualCount = Math.floor(obstaclePositions.length * difficultyMultiplier[gameSettings.difficulty]);
            if (gameSettings.difficulty === 'baby') {
                actualCount = Math.min(actualCount, 4);
            }

            // Evenly distribute obstacles throughout track for all difficulty modes
            let selectedPositions = [];
            if (actualCount > 0 && obstaclePositions.length > 0) {
                const spacing = obstaclePositions.length / actualCount;
                for (let i = 0; i < actualCount; i++) {
                    const idx = Math.min(Math.floor(spacing * i + spacing / 2), obstaclePositions.length - 1);
                    selectedPositions.push(obstaclePositions[idx]);
                }
            }

            selectedPositions.forEach((pos, index) => {
                // Check if position is on a bounce pad
                let onPad = false;
                for (const pad of ramps) {
                    const dx = pos.x - pad.x;
                    const dz = pos.z - pad.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    if (distance < pad.radius + 4) {
                        onPad = true;
                        break;
                    }
                }
                if (onPad) return;

                let obstacleMesh;
                let radius;

                if (gameSettings.obstacleType === 'cones') {
                    obstacleMesh = createCone(index);
                    radius = 2;
                } else if (gameSettings.obstacleType === 'crates') {
                    obstacleMesh = createCrate();
                    radius = 2.5;
                } else if (gameSettings.obstacleType === 'labubu') {
                    obstacleMesh = createLabubu(index);
                    radius = 2.5;
                }

                obstacleMesh.position.set(pos.x, obstacleMesh.userData.yOffset || 1.5, pos.z);
                obstacleMesh.castShadow = true;
                scene.add(obstacleMesh);

                // In hard mode, every other obstacle moves (ensures exactly half move)
                const isMoving = gameSettings.difficulty === 'hard' && (index % 2 === 0);

                obstacles.push({
                    mesh: obstacleMesh,
                    radius: radius,
                    isMoving: isMoving,
                    moveSpeed: 0.03 + Math.random() * 0.04,  // Faster movement
                    moveDirection: Math.random() > 0.5 ? 1 : -1,
                    originalX: pos.x,
                    moveRange: 8 + Math.random() * 6  // Larger movement range
                });
            });
        }

        function createCone(index) {
            const colors = [0xff6600, 0xffff00, 0x00ff00, 0xff00ff];
            const coneGeometry = new THREE.CylinderGeometry(0.5, 1.5, 3, 8);
            const coneMaterial = new THREE.MeshStandardMaterial({ color: colors[index % colors.length] });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.userData.yOffset = 1.5;
            return cone;
        }

        function createCrate() {
            const crateGeometry = new THREE.BoxGeometry(3, 3, 3);
            const crateMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const crate = new THREE.Mesh(crateGeometry, crateMaterial);
            crate.userData.yOffset = 1.5;
            return crate;
        }

        function createLabubu(index) {
            const labubuGroup = new THREE.Group();
            // Use probability-based color selection (1/36 for Secret black, 35/36 divided by 6 for others)
            const labubuColor = getRandomLabubuColor();

            // Fuzzy/plush material for body with soft appearance
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: labubuColor.color,
                roughness: 1.0,
                metalness: 0
            });

            // Slightly darker fur accent material
            const darkerColor = new THREE.Color(labubuColor.color).multiplyScalar(0.85);
            const furAccentMaterial = new THREE.MeshStandardMaterial({
                color: darkerColor,
                roughness: 1.0,
                metalness: 0
            });

            // === BODY - Round plush shape ===
            const bodyGeometry = new THREE.SphereGeometry(1.6, 32, 32);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.scale.set(1, 0.95, 0.85);
            body.position.y = 0;
            labubuGroup.add(body);

            // Add fur tufts on body for texture
            const furTuftGeometry = new THREE.SphereGeometry(0.25, 8, 8);
            const furPositions = [
                { x: -1.2, y: 0.5, z: 0.6 }, { x: 1.2, y: 0.5, z: 0.6 },
                { x: -1.0, y: -0.3, z: 0.8 }, { x: 1.0, y: -0.3, z: 0.8 },
                { x: 0, y: 0.8, z: 1.0 }, { x: -0.5, y: 0.6, z: 1.1 }, { x: 0.5, y: 0.6, z: 1.1 },
                { x: -1.3, y: 0, z: 0 }, { x: 1.3, y: 0, z: 0 }
            ];
            furPositions.forEach(pos => {
                const tuft = new THREE.Mesh(furTuftGeometry, furAccentMaterial);
                tuft.position.set(pos.x, pos.y, pos.z);
                tuft.scale.set(0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4, 0.6);
                labubuGroup.add(tuft);
            });

            // === HEAD - Large round head (signature Labubu proportions) ===
            const headGeometry = new THREE.SphereGeometry(1.7, 32, 32);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 2.4;
            head.scale.set(1.15, 1.05, 1);
            labubuGroup.add(head);

            // Cheek puffs for cuter look
            const cheekGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const leftCheek = new THREE.Mesh(cheekGeometry, bodyMaterial);
            leftCheek.position.set(-1.1, 1.9, 0.8);
            leftCheek.scale.set(1, 0.8, 0.6);
            labubuGroup.add(leftCheek);
            const rightCheek = new THREE.Mesh(cheekGeometry, bodyMaterial);
            rightCheek.position.set(1.1, 1.9, 0.8);
            rightCheek.scale.set(1, 0.8, 0.6);
            labubuGroup.add(rightCheek);

            // Head fur tufts
            const headFurPositions = [
                { x: -1.4, y: 2.8, z: 0.3 }, { x: 1.4, y: 2.8, z: 0.3 },
                { x: 0, y: 3.8, z: 0.2 }, { x: -0.6, y: 3.6, z: 0.3 }, { x: 0.6, y: 3.6, z: 0.3 }
            ];
            headFurPositions.forEach(pos => {
                const tuft = new THREE.Mesh(furTuftGeometry, furAccentMaterial);
                tuft.position.set(pos.x, pos.y, pos.z);
                tuft.scale.set(0.7 + Math.random() * 0.3, 0.9 + Math.random() * 0.3, 0.5);
                labubuGroup.add(tuft);
            });

            // === EARS - Long rabbit-like pointed ears (signature feature) ===
            // Create elongated ear using cylinder (r128 compatible)
            const earCylinderGeometry = new THREE.CylinderGeometry(0.38, 0.42, 1.8, 12);
            const leftEarBase = new THREE.Mesh(earCylinderGeometry, bodyMaterial);
            leftEarBase.position.set(-0.9, 4.2, -0.1);
            leftEarBase.rotation.z = 0.3;
            leftEarBase.rotation.x = -0.1;
            labubuGroup.add(leftEarBase);

            const rightEarBase = new THREE.Mesh(earCylinderGeometry, bodyMaterial);
            rightEarBase.position.set(0.9, 4.2, -0.1);
            rightEarBase.rotation.z = -0.3;
            rightEarBase.rotation.x = -0.1;
            labubuGroup.add(rightEarBase);

            // Ear rounded bottom caps
            const earCapGeometry = new THREE.SphereGeometry(0.42, 12, 12);
            const leftEarCap = new THREE.Mesh(earCapGeometry, bodyMaterial);
            leftEarCap.position.set(-0.75, 3.35, -0.05);
            leftEarCap.scale.set(1, 0.6, 1);
            labubuGroup.add(leftEarCap);
            const rightEarCap = new THREE.Mesh(earCapGeometry, bodyMaterial);
            rightEarCap.position.set(0.75, 3.35, -0.05);
            rightEarCap.scale.set(1, 0.6, 1);
            labubuGroup.add(rightEarCap);

            // Ear tips (pointed)
            const earTipGeometry = new THREE.ConeGeometry(0.38, 1.2, 8);
            const leftEarTip = new THREE.Mesh(earTipGeometry, bodyMaterial);
            leftEarTip.position.set(-1.1, 5.4, -0.15);
            leftEarTip.rotation.z = 0.3;
            labubuGroup.add(leftEarTip);

            const rightEarTip = new THREE.Mesh(earTipGeometry, bodyMaterial);
            rightEarTip.position.set(1.1, 5.4, -0.15);
            rightEarTip.rotation.z = -0.3;
            labubuGroup.add(rightEarTip);

            // Inner ear (gradient/lighter color) - using cylinder
            const innerEarCylinderGeometry = new THREE.CylinderGeometry(0.2, 0.24, 1.4, 12);
            const innerEarMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.8 });
            const leftInnerEar = new THREE.Mesh(innerEarCylinderGeometry, innerEarMaterial);
            leftInnerEar.position.set(-0.85, 4.15, 0.15);
            leftInnerEar.rotation.z = 0.3;
            leftInnerEar.rotation.x = -0.1;
            labubuGroup.add(leftInnerEar);

            const rightInnerEar = new THREE.Mesh(innerEarCylinderGeometry, innerEarMaterial);
            rightInnerEar.position.set(0.85, 4.15, 0.15);
            rightInnerEar.rotation.z = -0.3;
            rightInnerEar.rotation.x = -0.1;
            labubuGroup.add(rightInnerEar);

            // === EYES - Big wide gradient glittery eyes ===
            // Eye sockets (dark background)
            const eyeSocketGeometry = new THREE.SphereGeometry(0.55, 16, 16);
            const eyeSocketMaterial = new THREE.MeshBasicMaterial({ color: 0x0a0a0a });

            const leftEyeSocket = new THREE.Mesh(eyeSocketGeometry, eyeSocketMaterial);
            leftEyeSocket.position.set(-0.55, 2.5, 1.35);
            leftEyeSocket.scale.set(1.1, 1.2, 0.5);
            labubuGroup.add(leftEyeSocket);

            const rightEyeSocket = new THREE.Mesh(eyeSocketGeometry, eyeSocketMaterial);
            rightEyeSocket.position.set(0.55, 2.5, 1.35);
            rightEyeSocket.scale.set(1.1, 1.2, 0.5);
            labubuGroup.add(rightEyeSocket);

            // Gradient iris (big expressive eyes)
            const irisGeometry = new THREE.SphereGeometry(0.42, 16, 16);
            const irisMaterial = new THREE.MeshBasicMaterial({ color: labubuColor.gradient });
            const leftIris = new THREE.Mesh(irisGeometry, irisMaterial);
            leftIris.position.set(-0.55, 2.55, 1.5);
            leftIris.scale.set(1, 1.1, 0.35);
            labubuGroup.add(leftIris);

            const rightIris = new THREE.Mesh(irisGeometry, irisMaterial);
            rightIris.position.set(0.55, 2.55, 1.5);
            rightIris.scale.set(1, 1.1, 0.35);
            labubuGroup.add(rightIris);

            // Pupil
            const pupilGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.55, 2.5, 1.55);
            leftPupil.scale.set(1, 1.2, 0.3);
            labubuGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.55, 2.5, 1.55);
            rightPupil.scale.set(1, 1.2, 0.3);
            labubuGroup.add(rightPupil);

            // Eye sparkles (glitter effect - multiple sparkles per eye)
            const sparkleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const sparkleGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const smallSparkleGeometry = new THREE.SphereGeometry(0.06, 8, 8);

            // Left eye sparkles
            const leftSparkle1 = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
            leftSparkle1.position.set(-0.7, 2.7, 1.58);
            labubuGroup.add(leftSparkle1);
            const leftSparkle2 = new THREE.Mesh(smallSparkleGeometry, sparkleMaterial);
            leftSparkle2.position.set(-0.4, 2.4, 1.58);
            labubuGroup.add(leftSparkle2);
            const leftSparkle3 = new THREE.Mesh(smallSparkleGeometry, sparkleMaterial);
            leftSparkle3.position.set(-0.65, 2.35, 1.58);
            labubuGroup.add(leftSparkle3);

            // Right eye sparkles
            const rightSparkle1 = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
            rightSparkle1.position.set(0.4, 2.7, 1.58);
            labubuGroup.add(rightSparkle1);
            const rightSparkle2 = new THREE.Mesh(smallSparkleGeometry, sparkleMaterial);
            rightSparkle2.position.set(0.7, 2.4, 1.58);
            labubuGroup.add(rightSparkle2);
            const rightSparkle3 = new THREE.Mesh(smallSparkleGeometry, sparkleMaterial);
            rightSparkle3.position.set(0.45, 2.35, 1.58);
            labubuGroup.add(rightSparkle3);

            // === NOSE - Small cute nose ===
            const noseGeometry = new THREE.SphereGeometry(0.18, 12, 12);
            const noseMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.3 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 2.0, 1.6);
            nose.scale.set(1.3, 0.9, 0.8);
            labubuGroup.add(nose);

            // === MOUTH - Wide mischievous grin ===
            // Mouth opening (using torus for curved smile - r128 compatible)
            const mouthGeometry = new THREE.TorusGeometry(0.5, 0.12, 8, 16, Math.PI);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x1a0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.6, 1.4);
            mouth.rotation.x = Math.PI;
            mouth.rotation.z = Math.PI;
            labubuGroup.add(mouth);

            // Dark mouth interior
            const mouthInteriorGeometry = new THREE.SphereGeometry(0.45, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const mouthInteriorMaterial = new THREE.MeshBasicMaterial({ color: 0x330000, side: THREE.BackSide });
            const mouthInterior = new THREE.Mesh(mouthInteriorGeometry, mouthInteriorMaterial);
            mouthInterior.position.set(0, 1.6, 1.25);
            mouthInterior.rotation.x = Math.PI / 2;
            labubuGroup.add(mouthInterior);

            // === 9 SHARP TEETH - Signature Labubu mischievous smile! ===
            const toothMaterial = new THREE.MeshBasicMaterial({ color: 0xfffffe });
            const teethConfig = [
                { x: -0.42, size: 0.07, height: 0.22 },
                { x: -0.31, size: 0.09, height: 0.28 },
                { x: -0.18, size: 0.11, height: 0.32 },
                { x: -0.06, size: 0.10, height: 0.30 },
                { x: 0.06, size: 0.12, height: 0.35 },  // Center tooth slightly bigger
                { x: 0.18, size: 0.10, height: 0.30 },
                { x: 0.30, size: 0.11, height: 0.32 },
                { x: 0.41, size: 0.09, height: 0.28 },
                { x: 0.50, size: 0.07, height: 0.22 }
            ];

            teethConfig.forEach((t, i) => {
                const toothGeometry = new THREE.ConeGeometry(t.size, t.height, 6);
                const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                tooth.position.set(t.x, 1.38, 1.5);
                tooth.rotation.x = Math.PI;
                // Slight random rotation for natural look
                tooth.rotation.z = (Math.random() - 0.5) * 0.1;
                labubuGroup.add(tooth);
            });

            // === ARMS - Long fuzzy arms ===
            // Upper arm (using cylinder - r128 compatible)
            const upperArmGeometry = new THREE.CylinderGeometry(0.28, 0.28, 0.8, 12);
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            leftUpperArm.position.set(-1.6, 0.2, 0.2);
            leftUpperArm.rotation.z = 0.4;
            labubuGroup.add(leftUpperArm);

            const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            rightUpperArm.position.set(1.6, 0.2, 0.2);
            rightUpperArm.rotation.z = -0.4;
            labubuGroup.add(rightUpperArm);

            // Lower arm / hands
            const handGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const leftHand = new THREE.Mesh(handGeometry, bodyMaterial);
            leftHand.position.set(-2.1, -0.3, 0.4);
            leftHand.scale.set(0.9, 1, 0.8);
            labubuGroup.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, bodyMaterial);
            rightHand.position.set(2.1, -0.3, 0.4);
            rightHand.scale.set(0.9, 1, 0.8);
            labubuGroup.add(rightHand);

            // Tiny claws on hands
            const clawMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.3 });
            const clawGeometry = new THREE.ConeGeometry(0.06, 0.15, 6);
            [-2.0, 2.0].forEach(handX => {
                for (let i = 0; i < 3; i++) {
                    const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                    const offsetX = handX < 0 ? -0.15 : 0.15;
                    claw.position.set(handX + offsetX, -0.5, 0.55 + i * 0.12);
                    claw.rotation.x = Math.PI * 0.7;
                    labubuGroup.add(claw);
                }
            });

            // === LEGS - Stubby fuzzy legs (using cylinder - r128 compatible) ===
            const legGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.5, 12);
            const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLeg.position.set(-0.7, -1.3, 0);
            labubuGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            rightLeg.position.set(0.7, -1.3, 0);
            labubuGroup.add(rightLeg);

            // === FEET - Cute chubby feet ===
            const footGeometry = new THREE.SphereGeometry(0.55, 16, 16);
            const leftFoot = new THREE.Mesh(footGeometry, bodyMaterial);
            leftFoot.position.set(-0.7, -1.8, 0.35);
            leftFoot.scale.set(0.85, 0.45, 1.1);
            labubuGroup.add(leftFoot);

            const rightFoot = new THREE.Mesh(footGeometry, bodyMaterial);
            rightFoot.position.set(0.7, -1.8, 0.35);
            rightFoot.scale.set(0.85, 0.45, 1.1);
            labubuGroup.add(rightFoot);

            // Toenails / claws
            const toenailGeometry = new THREE.SphereGeometry(0.09, 8, 8);
            const toenailMaterial = new THREE.MeshStandardMaterial({ color: labubuColor.gradient, roughness: 0.3 });
            [-0.7, 0.7].forEach(footX => {
                for (let i = 0; i < 3; i++) {
                    const toenail = new THREE.Mesh(toenailGeometry, toenailMaterial);
                    toenail.position.set(footX + (i - 1) * 0.18, -1.85, 0.85);
                    toenail.scale.set(0.9, 0.5, 1.2);
                    labubuGroup.add(toenail);
                }
            });

            // === TAIL - Small fluffy tail puff ===
            const tailGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const tail = new THREE.Mesh(tailGeometry, furAccentMaterial);
            tail.position.set(0, -0.2, -1.35);
            tail.scale.set(1, 0.9, 0.8);
            labubuGroup.add(tail);

            // Extra tail fluff
            const tailFluffGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const tailFluff1 = new THREE.Mesh(tailFluffGeometry, bodyMaterial);
            tailFluff1.position.set(-0.2, -0.1, -1.5);
            labubuGroup.add(tailFluff1);
            const tailFluff2 = new THREE.Mesh(tailFluffGeometry, bodyMaterial);
            tailFluff2.position.set(0.2, -0.3, -1.5);
            labubuGroup.add(tailFluff2);

            // Glowing boundary ring (semi-transparent barrel) to show collision area
            const boundaryRadius = 2.5;  // Match collision radius
            const boundaryHeight = 6;
            const boundaryGeometry = new THREE.CylinderGeometry(boundaryRadius, boundaryRadius, boundaryHeight, 32, 1, true);
            const boundaryMaterial = new THREE.MeshBasicMaterial({
                color: labubuColor.ringColor,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide
            });
            const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            boundary.position.y = boundaryHeight / 2 - 1.5;
            labubuGroup.add(boundary);

            // Add a glowing ring at the base for extra visibility
            const baseRingGeometry = new THREE.TorusGeometry(boundaryRadius, 0.15, 8, 32);
            const baseRingMaterial = new THREE.MeshBasicMaterial({
                color: labubuColor.ringColor,
                transparent: true,
                opacity: 0.6
            });
            const baseRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.y = -1.5;
            labubuGroup.add(baseRing);

            // Add a second ring at the top
            const topRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
            topRing.rotation.x = Math.PI / 2;
            topRing.position.y = boundaryHeight - 1.5;
            labubuGroup.add(topRing);

            // For Secret black Labubu, add extra golden sparkle effect
            if (labubuColor.name === 'Secret') {
                const sparkleRingGeometry = new THREE.TorusGeometry(boundaryRadius + 0.3, 0.1, 8, 32);
                const sparkleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.8
                });
                for (let i = 0; i < 3; i++) {
                    const sparkleRing = new THREE.Mesh(sparkleRingGeometry, sparkleMaterial);
                    sparkleRing.rotation.x = Math.PI / 2;
                    sparkleRing.position.y = -1 + i * 2;
                    labubuGroup.add(sparkleRing);
                }
            }

            labubuGroup.userData.yOffset = 3;
            labubuGroup.userData.isLabubu = true;
            labubuGroup.userData.colorName = labubuColor.name;
            labubuGroup.userData.boundaryMesh = boundary;

            return labubuGroup;
        }

        function createFinishLine() {
            // Get the last waypoint for finish line position
            const lastWp = trackWaypoints[trackWaypoints.length - 1];
            const prevWp = trackWaypoints[trackWaypoints.length - 2];
            const finishAngle = Math.atan2(lastWp.x - prevWp.x, -(lastWp.z - prevWp.z));

            const finishGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 5);
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const squareSize = 32;
            for (let x = 0; x < canvas.width; x += squareSize) {
                for (let y = 0; y < canvas.height; y += squareSize) {
                    ctx.fillStyle = ((x + y) / squareSize) % 2 === 0 ? 'white' : 'black';
                    ctx.fillRect(x, y, squareSize, squareSize);
                }
            }
            const finishTexture = new THREE.CanvasTexture(canvas);
            finishTexture.wrapS = THREE.RepeatWrapping;
            finishTexture.wrapT = THREE.RepeatWrapping;
            finishTexture.repeat.set(4, 1);
            const finishMaterial = new THREE.MeshBasicMaterial({ map: finishTexture });
            const finishLine = new THREE.Mesh(finishGeometry, finishMaterial);
            finishLine.rotation.x = -Math.PI / 2;
            finishLine.rotation.z = -finishAngle;
            finishLine.position.set(lastWp.x, 0.02, lastWp.z);
            scene.add(finishLine);

            // Store finish line position for collision detection
            window.finishLinePos = { x: lastWp.x, z: lastWp.z };

            // Calculate perpendicular direction (across the track)
            const perpX = Math.cos(finishAngle);
            const perpZ = Math.sin(finishAngle);

            // Create banner with "FINISH" text
            const bannerCanvas = document.createElement('canvas');
            bannerCanvas.width = 512;
            bannerCanvas.height = 128;
            const bannerCtx = bannerCanvas.getContext('2d');

            // Checkered background
            const checkSize = 32;
            for (let bx = 0; bx < bannerCanvas.width; bx += checkSize) {
                for (let by = 0; by < bannerCanvas.height; by += checkSize) {
                    bannerCtx.fillStyle = ((bx + by) / checkSize) % 2 === 0 ? '#ffffff' : '#000000';
                    bannerCtx.fillRect(bx, by, checkSize, checkSize);
                }
            }

            // "FINISH" text
            bannerCtx.fillStyle = '#ff0000';
            bannerCtx.font = 'bold 80px Arial';
            bannerCtx.textAlign = 'center';
            bannerCtx.textBaseline = 'middle';
            bannerCtx.strokeStyle = '#ffffff';
            bannerCtx.lineWidth = 4;
            bannerCtx.strokeText('FINISH', bannerCanvas.width / 2, bannerCanvas.height / 2);
            bannerCtx.fillText('FINISH', bannerCanvas.width / 2, bannerCanvas.height / 2);

            // Calculate support post positions first
            const leftPostX = lastWp.x - perpX * (TRACK_WIDTH / 2 + 2);
            const leftPostZ = lastWp.z - perpZ * (TRACK_WIDTH / 2 + 2);
            const rightPostX = lastWp.x + perpX * (TRACK_WIDTH / 2 + 2);
            const rightPostZ = lastWp.z + perpZ * (TRACK_WIDTH / 2 + 2);

            // Create banner that spans between the posts
            const bannerTexture = new THREE.CanvasTexture(bannerCanvas);
            const bannerWidth = Math.sqrt(Math.pow(rightPostX - leftPostX, 2) + Math.pow(rightPostZ - leftPostZ, 2));
            const bannerGeometry = new THREE.PlaneGeometry(bannerWidth, 3);
            const bannerMaterial = new THREE.MeshBasicMaterial({ map: bannerTexture, side: THREE.DoubleSide });
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);

            // Position banner at center between posts, at height 8
            banner.position.set(
                (leftPostX + rightPostX) / 2,
                8,
                (leftPostZ + rightPostZ) / 2
            );

            // Calculate rotation to span between posts
            // PlaneGeometry width is along X axis, so we need rotation that aligns X with left-to-right direction
            const bannerAngle = Math.atan2(leftPostZ - rightPostZ, rightPostX - leftPostX);
            banner.rotation.y = bannerAngle;
            scene.add(banner);

            // Support posts on left and right sides of track
            const supportGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 8);
            const supportMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

            const leftSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            leftSupport.position.set(leftPostX, 5, leftPostZ);
            scene.add(leftSupport);

            const rightSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            rightSupport.position.set(rightPostX, 5, rightPostZ);
            scene.add(rightSupport);
        }

        function createScenery() {
            // Place trees along the curved track
            const treePositions = [];
            for (let i = 0; i < trackWaypoints.length; i += 2) {
                const wp = trackWaypoints[i];
                const nextWp = trackWaypoints[Math.min(i + 1, trackWaypoints.length - 1)];
                const angle = Math.atan2(nextWp.x - wp.x, -(nextWp.z - wp.z));
                const perpX = Math.cos(angle);
                const perpZ = Math.sin(angle);

                // Trees on both sides of track
                treePositions.push({
                    x: wp.x - perpX * (TRACK_WIDTH / 2 + 15 + Math.random() * 20),
                    z: wp.z - perpZ * (TRACK_WIDTH / 2 + 15 + Math.random() * 20)
                });
                treePositions.push({
                    x: wp.x + perpX * (TRACK_WIDTH / 2 + 15 + Math.random() * 20),
                    z: wp.z + perpZ * (TRACK_WIDTH / 2 + 15 + Math.random() * 20)
                });
            }

            treePositions.forEach(pos => {
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(pos.x + (Math.random() - 0.5) * 5, 2.5, pos.z + (Math.random() - 0.5) * 5);
                trunk.castShadow = true;
                scene.add(trunk);

                const foliageGeometry = new THREE.ConeGeometry(3, 6, 8);
                const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(trunk.position.x, 7, trunk.position.z);
                foliage.castShadow = true;
                scene.add(foliage);
            });

            const gridMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = 0; i < 3; i++) {
                const gridGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 0.5);
                const gridLine = new THREE.Mesh(gridGeometry, gridMaterial);
                gridLine.rotation.x = -Math.PI / 2;
                gridLine.position.set(0, 0.01, 5 - i * 3);
                scene.add(gridLine);
            }
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.isMoving) {
                    obstacle.mesh.position.x += obstacle.moveSpeed * obstacle.moveDirection;
                    if (Math.abs(obstacle.mesh.position.x - obstacle.originalX) > obstacle.moveRange) {
                        obstacle.moveDirection *= -1;
                    }
                    const maxX = TRACK_WIDTH / 2 - 3;
                    if (obstacle.mesh.position.x > maxX) {
                        obstacle.mesh.position.x = maxX;
                        obstacle.moveDirection = -1;
                    } else if (obstacle.mesh.position.x < -maxX) {
                        obstacle.mesh.position.x = -maxX;
                        obstacle.moveDirection = 1;
                    }
                    if (obstacle.mesh.userData && obstacle.mesh.userData.isLabubu) {
                        obstacle.mesh.rotation.y = obstacle.moveDirection > 0 ? Math.PI / 2 : -Math.PI / 2;
                    }
                }
            });
        }

        function updateBouncePads() {
            const time = Date.now() * 0.003;
            ramps.forEach((pad, index) => {
                if (pad.mesh && pad.mesh.userData.arrowGroup) {
                    const arrowGroup = pad.mesh.userData.arrowGroup;
                    // Bobbing animation
                    arrowGroup.position.y = Math.sin(time + index) * 0.3;
                    // Slow rotation
                    arrowGroup.rotation.y = time * 0.5;

                    // Pulse effect when recently bounced
                    if (pad.mesh.userData.bounceTime) {
                        const elapsed = Date.now() - pad.mesh.userData.bounceTime;
                        if (elapsed < 500) {
                            const scale = 1 + Math.sin(elapsed * 0.02) * 0.3;
                            arrowGroup.scale.set(scale, scale, scale);
                        } else {
                            arrowGroup.scale.set(1, 1, 1);
                            pad.mesh.userData.bounceTime = null;
                        }
                    }
                }
            });
        }

        function checkRamps() {
            // Don't trigger bounce if already jumping high
            if (car.isJumping && car.position.y > 2) {
                return;
            }

            // Check which pad the car is currently on
            let currentPadIdx = -1;
            for (let i = 0; i < ramps.length; i++) {
                const pad = ramps[i];
                const dx = car.position.x - pad.x;
                const dz = car.position.z - pad.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < pad.radius) {
                    currentPadIdx = i;
                    break;
                }
            }

            // Only launch if entering a NEW pad (not the same one we're already on)
            if (currentPadIdx !== -1 && currentPadIdx !== car.currentPadIndex && car.position.y < 2) {
                const pad = ramps[currentPadIdx];
                // Launch the car upward! Height based on speed
                // Baby mode: 3x jump height for extra fun!
                const speedFactor = Math.max(0.3, car.speed / CAR_MAX_SPEED);
                const jumpMultiplier = gameSettings.difficulty === 'baby' ? 3 : 1;
                car.velocityY = JUMP_VELOCITY * 1.5 * speedFactor * jumpMultiplier;
                car.isJumping = true;
                car.onRamp = true; // Mark as on pad to prevent collision damage

                // Visual feedback - make arrows pulse (handled in animate)
                if (pad.mesh && pad.mesh.userData.arrowGroup) {
                    pad.mesh.userData.bounceTime = Date.now();
                }
            }

            // Update current pad tracking
            car.currentPadIndex = currentPadIdx;

            // Reset onRamp if not on any pad and on ground
            if (currentPadIdx === -1 && car.position.y <= 1.1) {
                car.onRamp = false;
            }
        }

        // Check if a position is on the track
        function isOnTrack(x, z) {
            // Find the closest point on the track centerline using smooth spline
            let minDist = Infinity;

            const points = smoothTrackPoints.length > 0 ? smoothTrackPoints : trackWaypoints;

            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                const x1 = p1.x, z1 = p1.z;
                const x2 = p2.x, z2 = p2.z;

                // Find closest point on this segment
                const closest = closestPointOnSegment(x, z, x1, z1, x2, z2);
                const dx = x - closest.x;
                const dz = z - closest.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < minDist) {
                    minDist = dist;
                }
            }

            // Check if within track width (with a small margin)
            return minDist < (TRACK_WIDTH / 2 + 2);
        }

        function updateCarPhysics() {
            // Apply gravity when jumping
            // Space mode: 50% gravity for 2x higher jumps and slower landing
            if (car.isJumping || car.position.y > 1.01) {
                const wasInAir = car.position.y > 1.1;
                const gravityMultiplier = gameSettings.difficulty === 'space' ? 0.5 : 1;
                car.velocityY -= GRAVITY * gravityMultiplier;
                car.position.y += car.velocityY;

                if (car.position.y <= 1) {
                    car.position.y = 1;
                    car.velocityY = 0;
                    car.isJumping = false;

                    // Check if landed outside the track
                    if (wasInAir && !isOnTrack(car.position.x, car.position.z)) {
                        triggerOffTrackGameOver();
                    }
                }
            }
        }

        function triggerOffTrackGameOver() {
            if (multiplayerActive) {
                // In multiplayer, respawn with penalty instead of game over
                respawnWithPenalty('Landed off track!');
                return;
            }
            gameOver = true;
            gameFinished = true;
            const message = document.getElementById('message');
            const restartHint = isMobile ? 'Tap ↺ to try again' : 'Press SPACE to try again';
            message.innerHTML = `WASTED!<br><span style="font-size: 24px; color: #ff6b6b;">Landed off the track!</span><br><span style="font-size: 20px;">${restartHint}</span>`;
            message.style.display = 'block';
            message.style.color = '#ff0000';
        }

        function updateCar(delta) {
            if (!gameStarted || gameFinished || gameOver || isPenaltyActive) return;

            const prevX = car.position.x;
            const prevZ = car.position.z;
            const isInAir = car.isJumping || car.position.y > 1.1;

            // Baby mode: 1/3 acceleration for easier control
            const accelMultiplier = gameSettings.difficulty === 'baby' ? 0.33 : 1;

            // Track if down key was released (for reverse logic)
            if (!isKeyPressed('ArrowDown')) {
                car.canReverse = true;
            }

            if (isInAir) {
                // In air: baby mode allows acceleration, others don't
                if (gameSettings.difficulty === 'baby' && isKeyPressed('ArrowUp')) {
                    car.speed += CAR_ACCELERATION * accelMultiplier;
                }
                // Braking at half rate, can only slow down to 0 (no reverse)
                if (isKeyPressed('ArrowDown') && car.speed > 0) {
                    car.speed -= CAR_BRAKE_FORCE / 2;
                    if (car.speed < 0) car.speed = 0;
                }
            } else {
                // On ground: normal controls
                if (isKeyPressed('ArrowUp')) {
                    // If moving backwards, accelerate forward at 1/10 rate (no release required)
                    if (car.speed < 0) {
                        car.speed += (CAR_ACCELERATION / 10) * accelMultiplier;
                    } else {
                        car.speed += CAR_ACCELERATION * accelMultiplier;
                    }
                }
                if (isKeyPressed('ArrowDown')) {
                    if (car.speed > 0) {
                        // Braking - slow down to 0
                        car.speed -= CAR_BRAKE_FORCE * accelMultiplier;
                        if (car.speed < 0) {
                            car.speed = 0;
                            car.canReverse = false;  // Must release before reversing
                        }
                    } else if (car.speed === 0 && car.canReverse) {
                        // Can start reversing (released brake after stopping)
                        car.speed -= (CAR_BRAKE_FORCE / 10) * accelMultiplier;
                    } else if (car.speed < 0) {
                        // Already reversing, continue at slow rate
                        car.speed -= (CAR_BRAKE_FORCE / 10) * accelMultiplier;
                    }
                    // If speed is 0 and canReverse is false, do nothing (must release first)
                }
            }

            car.speed *= (1 - CAR_FRICTION);

            // Speed limits: full reverse only on ground, no reverse in air
            if (isInAir) {
                car.speed = Math.max(0, Math.min(CAR_MAX_SPEED, car.speed));
            } else {
                car.speed = Math.max(-CAR_MAX_SPEED / 2, Math.min(CAR_MAX_SPEED, car.speed));
            }

            if (Math.abs(car.speed) > 0.01) {
                // Half turning capability when in air
                const turnSpeed = isInAir ? CAR_TURN_SPEED / 2 : CAR_TURN_SPEED;
                if (isKeyPressed('ArrowLeft')) {
                    car.rotation += turnSpeed * Math.sign(car.speed);
                }
                if (isKeyPressed('ArrowRight')) {
                    car.rotation -= turnSpeed * Math.sign(car.speed);
                }
            }

            const moveX = -Math.sin(car.rotation) * car.speed;
            const moveZ = -Math.cos(car.rotation) * car.speed;

            car.position.x += moveX;
            car.position.z += moveZ;

            checkRamps();
            updateCarPhysics();

            // Stop if game ended (e.g., landed off track) but update mesh first
            if (gameOver || gameFinished) {
                car.mesh.position.copy(car.position);
                car.mesh.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
                return;
            }

            // Only check collisions if on the ground (not jumping)
            if (car.position.y < 1.5 && !car.isJumping) {
                checkCollisions(prevX, prevZ, moveX, moveZ);
            }

            car.mesh.position.copy(car.position);

            // Tilt car and camera forward when in the air so player can see the ground
            // Tilt is relative to car's facing direction (local pitch, not world X)
            if (car.airTilt === undefined) car.airTilt = 0;

            if (car.isJumping || car.position.y > 1.5) {
                // More tilt when higher, and extra tilt when moving slow (dropping straight down)
                const heightFactor = Math.min(1, (car.position.y - 1) / 8);
                const speedFactor = 1 - Math.min(1, Math.abs(car.speed) / CAR_MAX_SPEED);  // Higher when slower
                // Base tilt + height bonus + slow speed bonus (more aggressive when dropping)
                const targetTilt = 0.25 + heightFactor * 0.25 + speedFactor * heightFactor * 0.3;
                // Smooth transition
                car.airTilt = car.airTilt * 0.9 + targetTilt * 0.1;
            } else {
                // Smoothly return to level when on ground
                car.airTilt *= 0.8;
                if (Math.abs(car.airTilt) < 0.01) car.airTilt = 0;
            }

            // Apply rotation using quaternion to tilt forward in car's local space
            const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
            const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -car.airTilt);
            // Combine: first yaw (heading), then pitch (tilt forward relative to heading)
            const combinedQuat = yawQuat.multiply(pitchQuat);
            car.mesh.quaternion.copy(combinedQuat);

            const cameraOffset = new THREE.Vector3(0, 1.5, 0.5);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
            camera.position.copy(car.position).add(cameraOffset);
            // Camera also tilts in local space
            camera.quaternion.copy(combinedQuat);

            // Check if reached finish line
            if (window.finishLinePos) {
                const distToFinish = Math.sqrt(
                    Math.pow(car.position.x - window.finishLinePos.x, 2) +
                    Math.pow(car.position.z - window.finishLinePos.z, 2)
                );
                if (distToFinish < 15) {
                    finishGame();
                }
            }
        }

        const CAR_HALF_WIDTH = 1.5;

        // Helper function to find closest point on a line segment
        function closestPointOnSegment(px, pz, x1, z1, x2, z2) {
            const dx = x2 - x1;
            const dz = z2 - z1;
            const len2 = dx * dx + dz * dz;
            if (len2 === 0) return { x: x1, z: z1 };

            let t = ((px - x1) * dx + (pz - z1) * dz) / len2;
            t = Math.max(0, Math.min(1, t));

            return {
                x: x1 + t * dx,
                z: z1 + t * dz
            };
        }

        function checkCollisions(prevX, prevZ, moveX, moveZ) {
            const currentTime = Date.now();
            const collisionCooldown = 300;
            let collided = false;

            const carRadius = CAR_HALF_WIDTH;

            // Check track boundary using smooth spline centerline
            // IMPORTANT: Only check segments near the car's current progress to avoid
            // issues on hairpin tracks where different parts of track are close together
            let minDist = Infinity;
            let closestPoint = null;
            let closestIndex = carTrackIndex;

            const points = smoothTrackPoints.length > 0 ? smoothTrackPoints : trackWaypoints;

            // Search window: check segments within a range of current position
            // Allow more forward search than backward to handle normal progression
            const searchBack = 30;
            const searchForward = 60;
            const startIdx = Math.max(0, carTrackIndex - searchBack);
            const endIdx = Math.min(points.length - 1, carTrackIndex + searchForward);

            for (let i = startIdx; i < endIdx; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                const x1 = p1.x, z1 = p1.z;
                const x2 = p2.x, z2 = p2.z;

                const closest = closestPointOnSegment(
                    car.position.x, car.position.z,
                    x1, z1, x2, z2
                );

                const dx = car.position.x - closest.x;
                const dz = car.position.z - closest.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = closest;
                    closestIndex = i;
                }
            }

            // Update car's track index (only move forward, or allow small backward)
            if (closestIndex > carTrackIndex || closestIndex >= carTrackIndex - 10) {
                carTrackIndex = closestIndex;
            }

            // If car is outside track bounds, push it back toward centerline
            // But if WAY off track, trigger game over instead
            const maxDist = TRACK_WIDTH / 2 - carRadius - 1;
            const wastedDist = maxDist * 2;  // If this far off, car is wasted
            if (minDist > maxDist && closestPoint) {
                if (minDist > wastedDist) {
                    // Car is way off track - game over!
                    triggerOffTrackGameOver();
                    return;
                }
                // Just slightly off - push back (invisible wall)
                const dx = car.position.x - closestPoint.x;
                const dz = car.position.z - closestPoint.z;
                if (minDist > 0.01) {
                    const nx = dx / minDist;
                    const nz = dz / minDist;
                    car.position.x = closestPoint.x + nx * maxDist;
                    car.position.z = closestPoint.z + nz * maxDist;
                }
                collided = true;
            }

            // Check obstacle collisions
            obstacles.forEach(obstacle => {
                const dx = car.position.x - obstacle.mesh.position.x;
                const dz = car.position.z - obstacle.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDist = obstacle.radius + carRadius;

                if (distance < minDist) {
                    if (distance > 0.01) {
                        const nx = dx / distance;
                        const nz = dz / distance;
                        car.position.x = obstacle.mesh.position.x + nx * minDist;
                        car.position.z = obstacle.mesh.position.z + nz * minDist;
                        const dotProduct = (moveX * nx + moveZ * nz);
                        if (dotProduct < 0) {
                            collided = true;
                        }
                    } else {
                        car.position.x = prevX;
                        car.position.z = prevZ;
                        collided = true;
                    }
                }
            });

            // Prevent going backwards past start - but only at the beginning of the race
            // Don't apply this on hairpin tracks where the road doubles back past the start line
            if (car.position.z > 10 && carTrackIndex < 20) {
                car.position.z = 10;
                collided = true;
            }

            // Only apply collision damage once when ENTERING a collision
            // (not continuously while staying in collision)
            if (collided && !car.onRamp) {
                if (!car.wasColliding) {
                    // Just entered a collision - apply damage once
                    applyCollisionEffect();
                }
                car.wasColliding = true;
            } else {
                // No longer colliding - reset the flag
                car.wasColliding = false;
            }
        }

        function applyCollisionEffect() {
            car.speed *= COLLISION_SLOWDOWN;
            lastCollisionTime = Date.now();

            // Reduce health
            health -= COLLISION_DAMAGE;
            if (health < 0) health = 0;
            updateHealthBar();

            const flash = document.getElementById('collision-flash');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 100);

            // Check for game over
            if (health <= 0) {
                triggerGameOver();
            }
        }

        function updateHealthBar() {
            const healthBar = document.getElementById('health-bar');
            const percentage = (health / MAX_HEALTH) * 100;
            healthBar.style.width = percentage + '%';

            healthBar.classList.remove('medium', 'low');
            if (percentage <= 30) {
                healthBar.classList.add('low');
            } else if (percentage <= 60) {
                healthBar.classList.add('medium');
            }
        }

        function triggerGameOver() {
            if (multiplayerActive) {
                // In multiplayer, respawn with penalty instead of game over
                respawnWithPenalty('Car destroyed!');
                return;
            }
            gameOver = true;
            gameFinished = true;
            const message = document.getElementById('message');
            const restartHint = isMobile ? 'Tap ↺ to try again' : 'Press SPACE to try again';
            message.innerHTML = `WASTED!<br><span style="font-size: 24px; color: #ff6b6b;">Your car is destroyed!</span><br><span style="font-size: 20px;">${restartHint}</span>`;
            message.style.display = 'block';
            message.style.color = '#ff0000';
        }

        function respawnWithPenalty(reason) {
            if (isPenaltyActive) return; // Prevent multiple penalties
            isPenaltyActive = true;

            // Show penalty message
            const message = document.getElementById('message');
            message.innerHTML = `<span style="color: #ff6b6b;">${reason}</span><br><span style="font-size: 24px;">2 SEC PENALTY</span>`;
            message.style.display = 'block';
            message.style.color = '#ffff00';

            // Find a safe respawn position on the track
            // Use current progress to find nearby track point
            const respawnIndex = Math.max(0, carTrackIndex - 5);
            const trackPoint = trackPoints[respawnIndex];

            // Reset car state
            car.position.x = trackPoint.x;
            car.position.z = trackPoint.z;
            car.position.y = 1;
            car.speed = 0;
            car.velocityY = 0;
            car.isJumping = false;
            car.onRamp = false;
            car.airTilt = 0;

            // Calculate rotation to face track direction
            if (respawnIndex < trackPoints.length - 1) {
                const nextPoint = trackPoints[respawnIndex + 1];
                car.rotation = Math.atan2(nextPoint.x - trackPoint.x, nextPoint.z - trackPoint.z);
            }

            // Reset health
            health = MAX_HEALTH;
            updateHealthBar();

            // Update car mesh position
            car.mesh.position.copy(car.position);
            car.mesh.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);

            // Flash the car for 2 seconds
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                car.mesh.visible = !car.mesh.visible;
                flashCount++;
                if (flashCount >= 20) { // 20 flashes over 2 seconds (100ms each)
                    clearInterval(flashInterval);
                    car.mesh.visible = true;
                    isPenaltyActive = false;
                    message.style.display = 'none';
                }
            }, 100);
        }

        function finishGame() {
            gameFinished = true;

            // Send finish event to opponent
            if (multiplayerActive && conn && conn.open) {
                conn.send({ type: 'finish', time: gameTime });
            }

            const message = document.getElementById('message');
            const restartHint = isMobile ? 'Tap ↺ to restart' : 'Press SPACE to restart';

            // Show multiplayer results if applicable
            let resultText = `FINISH!<br>Your Time: ${gameTime.toFixed(2)}s`;
            if (multiplayerActive && opponentFinishTime !== null) {
                if (gameTime < opponentFinishTime) {
                    resultText += `<br><span style="color: #ffd700; font-size: 36px;">YOU WIN!</span>`;
                    resultText += `<br><span style="font-size: 20px;">Opponent: ${opponentFinishTime.toFixed(2)}s</span>`;
                } else if (gameTime > opponentFinishTime) {
                    resultText += `<br><span style="color: #ff6b6b; font-size: 28px;">Opponent wins!</span>`;
                    resultText += `<br><span style="font-size: 20px;">Opponent: ${opponentFinishTime.toFixed(2)}s</span>`;
                } else {
                    resultText += `<br><span style="color: #feca57; font-size: 28px;">It's a TIE!</span>`;
                }
            } else if (multiplayerActive) {
                resultText += `<br><span style="font-size: 20px; color: #00ffff;">Waiting for opponent...</span>`;
            }
            resultText += `<br><span style="font-size: 24px">${restartHint}</span>`;

            message.innerHTML = resultText;
            message.style.display = 'block';
            message.style.color = '#00ff00';
        }

        function restartGame() {
            car.position.set(0, 1, 0);
            car.rotation = 0;
            car.speed = 0;
            car.velocityY = 0;
            car.isJumping = false;
            car.onRamp = false;
            car.wasColliding = false;
            car.currentPadIndex = -1;
            car.airTilt = 0;
            car.canReverse = true;
            carTrackIndex = 0; // Reset track progress
            gameTime = 0;
            gameStarted = false;
            gameFinished = false;
            gameOver = false;
            health = MAX_HEALTH;
            updateHealthBar();

            // Reset multiplayer state for new race
            opponentFinishTime = null;
            isPenaltyActive = false;
            if (opponentCar) {
                opponentCar.position.set(0, 1, 2); // Slightly behind player
                opponentCar.rotation.y = 0;
            }

            car.mesh.position.copy(car.position);
            car.mesh.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation);
            camera.position.set(0, 2.5, 0.5);
            camera.quaternion.set(0, 0, 0, 1);  // Reset to identity

            obstacles.forEach(obstacle => {
                if (obstacle.isMoving) {
                    obstacle.mesh.position.x = obstacle.originalX;
                }
            });

            const message = document.getElementById('message');
            message.innerHTML = isMobile ? 'READY!<br>Touch controls to Start' : 'READY!<br>Press Arrow Keys to Start';
            message.style.display = 'block';
            message.style.color = '#ffff00';
        }

        function updateUI() {
            const mph = Math.abs(car.speed * 60).toFixed(0);
            document.getElementById('speedometer').textContent = `${mph} MPH`;
            document.getElementById('timer').textContent = `Time: ${gameTime.toFixed(2)}s`;

            // Calculate progress along curved track
            let closestDist = Infinity;
            let closestIndex = 0;
            for (let i = 0; i < trackWaypoints.length; i++) {
                const wp = trackWaypoints[i];
                const dist = Math.sqrt(
                    Math.pow(car.position.x - wp.x, 2) +
                    Math.pow(car.position.z - wp.z, 2)
                );
                if (dist < closestDist) {
                    closestDist = dist;
                    closestIndex = i;
                }
            }
            const progress = Math.max(0, Math.min(100, (closestIndex / (trackWaypoints.length - 1)) * 100));
            document.getElementById('lap').textContent = `Progress: ${progress.toFixed(0)}%`;
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        let lastTime = 0;
        function drawMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');

            // Set canvas resolution
            canvas.width = 150;
            canvas.height = 150;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 30, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (smoothTrackPoints.length === 0) return;

            // Calculate track bounds
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (const p of smoothTrackPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minZ = Math.min(minZ, p.z);
                maxZ = Math.max(maxZ, p.z);
            }

            // Add padding
            const padding = 50;
            minX -= padding;
            maxX += padding;
            minZ -= padding;
            maxZ += padding;

            // Scale to fit canvas
            const scaleX = canvas.width / (maxX - minX);
            const scaleZ = canvas.height / (maxZ - minZ);
            const scale = Math.min(scaleX, scaleZ) * 0.9;

            const offsetX = canvas.width / 2 - ((maxX + minX) / 2) * scale;
            const offsetZ = canvas.height / 2 - ((maxZ + minZ) / 2) * scale;

            // Transform function
            const toCanvas = (x, z) => ({
                x: x * scale + offsetX,
                y: z * scale + offsetZ
            });

            // Draw track
            ctx.strokeStyle = '#444';
            ctx.lineWidth = Math.max(TRACK_WIDTH * scale * 0.8, 3);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let i = 0; i < smoothTrackPoints.length; i++) {
                const p = toCanvas(smoothTrackPoints[i].x, smoothTrackPoints[i].z);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Draw track center line (lighter)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            for (let i = 0; i < smoothTrackPoints.length; i++) {
                const p = toCanvas(smoothTrackPoints[i].x, smoothTrackPoints[i].z);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw start/finish
            const start = toCanvas(smoothTrackPoints[0].x, smoothTrackPoints[0].z);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(start.x - 3, start.y - 3, 6, 6);

            const end = toCanvas(
                smoothTrackPoints[smoothTrackPoints.length - 1].x,
                smoothTrackPoints[smoothTrackPoints.length - 1].z
            );
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(end.x - 3, end.y - 3, 6, 6);

            // Draw car position
            const carPos = toCanvas(car.position.x, car.position.z);
            ctx.fillStyle = '#00aaff';
            ctx.beginPath();
            ctx.arc(carPos.x, carPos.y, 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw car direction indicator
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(carPos.x, carPos.y);
            ctx.lineTo(
                carPos.x + Math.sin(car.rotation) * 8,
                carPos.y - Math.cos(car.rotation) * 8
            );
            ctx.stroke();
        }

        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);
            const delta = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (gameStarted && !gameFinished) {
                gameTime += delta;

                // Health regeneration - slowly recover health over time (more fun for kids!)
                // Baby mode: 2 HP/sec, other modes: ~0.67 HP/sec (1/3 rate)
                const baseRegen = gameSettings.difficulty === 'baby' ? 2 : 0.67;
                const regenRate = baseRegen * delta;
                if (health < MAX_HEALTH) {
                    health = Math.min(MAX_HEALTH, health + regenRate);
                    updateHealthBar();
                }
            }

            updateObstacles();
            updateBouncePads();
            updateCar(delta);
            updateUI();
            drawMinimap();

            // Send multiplayer position updates (throttled to ~20 times/sec)
            if (multiplayerActive && gameStarted && !gameFinished) {
                if (!window.lastPositionUpdate || currentTime - window.lastPositionUpdate > 50) {
                    sendPositionUpdate();
                    window.lastPositionUpdate = currentTime;
                }
            }

            // Update sounds based on car state
            if (gameStarted && !gameFinished && !gameOver) {
                updateEngineSound();
                updateBrakeSound();
            } else {
                stopAllSounds();
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
